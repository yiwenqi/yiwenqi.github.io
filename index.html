<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/14/Redis_v2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/14/Redis_v2/" class="post-title-link" itemprop="url">Redis进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-14 10:29:05 / 修改时间：23:28:22" itemprop="dateCreated datePublished" datetime="2024-07-14T10:29:05+08:00">2024-07-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis-v2"><a href="#Redis-v2" class="headerlink" title="Redis_v2"></a>Redis_v2</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>key 命令：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>del key</td>
<td>删除指定的key， 可以同时删除多个：del key1 key2 …</td>
</tr>
<tr>
<td align="center">2</td>
<td>dump key</td>
<td>序列号给定key</td>
</tr>
<tr>
<td align="center">3</td>
<td>exist key</td>
<td>检查key是否存在</td>
</tr>
<tr>
<td align="center">4</td>
<td>expire key second</td>
<td>给key设置过期时间</td>
</tr>
<tr>
<td align="center">5</td>
<td>key pattern</td>
<td>查找所有符合（pattern）的key； （*代表多个，？代表一个）</td>
</tr>
<tr>
<td align="center">6</td>
<td>persist key</td>
<td>移除key的过期时间</td>
</tr>
<tr>
<td align="center">7</td>
<td>ttl key</td>
<td>返回key的剩余生存时间</td>
</tr>
<tr>
<td align="center">8</td>
<td>type key</td>
<td>返回key的类型</td>
</tr>
<tr>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>String 命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SET</td>
<td align="left">设置指定 key 的值</td>
</tr>
<tr>
<td align="left">GET</td>
<td align="left">获取指定 key 的值</td>
</tr>
<tr>
<td align="left">getrange</td>
<td align="left">返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td align="left">getset</td>
<td align="left">将给定 key 的值设为 value ，并返回 key 的旧值 ( old value )</td>
</tr>
<tr>
<td align="left">mget</td>
<td align="left">获取所有(一个或多个)给定 key 的值</td>
</tr>
<tr>
<td align="left">setex</td>
<td align="left">设置 key 的值为 value 同时将过期时间设为 seconds</td>
</tr>
<tr>
<td align="left">setnx</td>
<td align="left">只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td align="left">mset</td>
<td align="left">同时设置一个或多个 key-value 对</td>
</tr>
<tr>
<td align="left">incr</td>
<td align="left">将 key 中储存的数字值增一</td>
</tr>
<tr>
<td align="left">append</td>
<td align="left">将 value 追加到 key 原来的值的末尾</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>Hash 命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HDEL key field1 [field2]</td>
<td align="left">删除一个或多个hash字段</td>
</tr>
<tr>
<td align="left">Hget key field</td>
<td align="left">获取哈希表中指定字段的值</td>
</tr>
<tr>
<td align="left">Hkeys key</td>
<td align="left">获取哈希表中所有字段</td>
</tr>
<tr>
<td align="left">HValue</td>
<td align="left">获取哈希表中所有值</td>
</tr>
<tr>
<td align="left">Hset key filed value</td>
<td align="left">将哈希表key中的字段field设置为value</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>更多资料查看：<a target="_blank" rel="noopener" href="https://redis.com.cn/commands.html">https://redis.com.cn/commands.html</a></p>
<h2 id="Redis中不同的类型的数据结构"><a href="#Redis中不同的类型的数据结构" class="headerlink" title="Redis中不同的类型的数据结构"></a>Redis中不同的类型的数据结构</h2><ul>
<li>介绍：redis中有以下五种数据结构<ul>
<li>string ， list， hash，set， zset（有序集合列表）</li>
</ul>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>介绍：string类型的底层数据结构实现主要是int，sds（简单动态字符串），与常规C字符串的区别是：<ul>
<li>SDS不仅可以保存文本数据，还可以保存二进制数据；</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查</li>
</ul>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong></p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_list_%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0.png" alt="redis_list_内部实现"></p>
<p>常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"># 将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"># 移除并返回key列表的头元素</span><br><span class="line">LPOP key     </span><br><span class="line"># 移除并返回key列表的尾元素</span><br><span class="line">RPOP key </span><br><span class="line"></span><br><span class="line"># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span><br><span class="line">LRANGE key start stop</span><br><span class="line"></span><br><span class="line"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>



<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>消息队列在存取消息时，必须要满足两个需求，分别是<strong>消息保序、和保证消息可靠性</strong>。</p>
<p>1、如何满足消息的顺序性；</p>
<p>​    List本身就是按照先进先出的顺序对数据进行存取；因此本身数据结构就支持顺序性；</p>
<p>​	我们在使用List的时候按照：LPUST+RPOP（或者反过来RPUSH+LPOP），即可实现顺序性；</p>
<p>2、若列表中没有数据，消费者会不断的循环加载，消耗CPU性能；此时可以使用<code>BRPOP</code>，当没有内容时会进行阻塞，但是同样当限制时间过长时会<strong>断开连接</strong>；此时需要进行<strong>异常处理重试</strong>；</p>
<p>3、如何保证消息可靠性？</p>
<p>​	 当服务拿到消费数据时出现异常，此时以前的数据将会丢失；为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p>
<p>缺陷：</p>
<ul>
<li>不支持多个消费者消费同一条消息；</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>介绍：Hash 是一个键值对（key - value）集合，其中 value 的形式如： <code>value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</code>。Hash 特别适合用于存储对象。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/hash%E4%B8%8Estring.png" alt="hash与string"></p>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h5><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</p>
<p>我们以用户信息为例，它在关系型数据库中的结构是这样的：</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF.webp" alt="用户信息"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; HMSET uid:1 name Tom age 15</span><br><span class="line">2</span><br><span class="line"># 存储一个哈希表uid:2的键值</span><br><span class="line">&gt; HMSET uid:2 name Jerry age 13</span><br><span class="line">2</span><br><span class="line"># 获取哈希表用户id为1中所有的键值</span><br><span class="line">&gt; HGETALL uid:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;15&quot;</span><br></pre></td></tr></table></figure>



<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>介绍：Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<p>redis 运算操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 交集运算</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"># 将交集结果存入新集合destination中</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 并集运算</span><br><span class="line">SUNION key [key ...]</span><br><span class="line"># 将并集结果存入新集合destination中</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 差集运算</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"># 将差集结果存入新集合destination中</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>

<h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>
<p>但是要提醒你一下，这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计；</p>
<h6 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h6><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id</p>
<h6 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h6><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<h6 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h6><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次</p>
<h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>介绍：Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p>
<p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<h5 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li>排行榜</li>
<li>电话、姓名排序</li>
</ul>
<h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>介绍：Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。</p>
<h5 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h5><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p>
<h5 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h5><p>签到统计（只有0&#x2F;1）,判断用户登陆态 , 连续签到用户总数</p>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>介绍：redis 2.8.9 版本新增类型。提供不精确的去重计算，官方提供误差率不超过0.81%</p>
<p>应用场景：百万级别网页UV计数；</p>
<h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><p>介绍：redis GEO 是Redis3.2版本新增的数据类型，主要用于存储地理位置信息；</p>
<p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p>
<p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数；</p>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>介绍：redis 5.0 版本新增的数据类型，Redis专门为消息队列设计的数据类型；</p>
<p>背景：之前<code>list</code>实现的消息队列有以下缺点</p>
<ul>
<li>发布订阅模式，不能持久化无法可靠的保存消息；重连的客户端无法读到历史记录；</li>
<li>List实现消息队列无法进行重复消费，消息消费完之后就会被删除；</li>
</ul>
<p>基于以上问题：</p>
<p>Stream类型</p>
<ul>
<li>支持消息的持久化，支持自动生成全局唯一ID，支持ACK确认的模式，支持消费组模式；</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>介绍：<code>RDB</code>文件内容是二进制数据， 默认开启；RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据；因此在 Redis 恢复数据时，RDB 恢复数据的效率会比 AOF 高些；</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>介绍：<code>AOF（Append Only File）</code>,将redis执行的每条写操作命令都追加到一个文件里；默认不开启；</p>
<p><strong>AOF先执行写操作命令</strong>，执行成功之后才会进行持久化保存, 这样做有以下几个优势：</p>
<ul>
<li>避免额外的语法检查开销</li>
<li>不会阻塞当前写操作命令的执行；但会给下一条命令带来阻塞风险；</li>
</ul>
<p>因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作是同步的。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_aof%E6%93%8D%E4%BD%9C.png" alt="redis_aof操作"></p>
<p>如果服务器磁盘I&#x2F;O压力过大，会导致写入速度很慢，从而导致阻塞下条命令执行；</p>
<h4 id="三种写策略"><a href="#三种写策略" class="headerlink" title="三种写策略"></a>三种写策略</h4><p>Redis 写入 AOF 日志的过程，如下图：</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_AOF%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="redis_AOF的写操作流程"></p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 <strong>3 种写回硬盘的策略</strong>，控制的就是上面说的第三步的过程。</p>
<p>在redis.conf配置文件中 <code>appendfsync</code>配置项有三个可选参数：</p>
<ul>
<li>always，每次执行写操作命令，同步将AOF日志数据写回硬盘；</li>
<li>Everysec， 先将命令写入到AOF文件的内核缓冲区，每隔一秒将缓冲区的内容写入到硬盘；</li>
<li>NO， 由操作系统控制写入磁盘的时机，该参数性能较好；</li>
</ul>
<p>以上三个配置项的使用场景：</p>
<ul>
<li><p>Always 策略的话，可以<strong>最大程度保证数据不丢失</strong>，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；</p>
</li>
<li><p>No 策略的话，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always <strong>策略性能较好</strong>，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。</p>
</li>
<li><p>Everysec 策略的话，是<strong>折中的一种方式</strong>，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/appendfsync%E7%9A%84%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AE.png"></p>
</li>
</ul>
<h5 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h5><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。</p>
<p>所以Redis提供 <code>AOF</code>重写机制，当AOF文件大小超过指定阈值时，Redis就会启用AOF重写机制，来压缩AOF文件；</p>
<p>AOF重写机制就是在重写时，读取当前数据库中的所有键值对，然后每一个键值对用一个命令记录到 <strong>新的AOF文件</strong>，然后用新的AOF文件替换旧AOF文件</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6.png" alt="AOF重写机制"></p>
<h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>redis的重写过程由后台子进程<code>bgrewriteaof</code> （bg后台）完成：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本（<em>数据副本怎么产生的后面会说</em>），这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p>linux系统中，并不会把父进程的内存拷贝一份给子进程，而是在父子进程中任意一方进行内存页修改时，才会进行复制；</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_bgrewirteaof_%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png" alt="redis_bgrewirteaof_写时复制"></p>
<h5 id="RDB-和-AOF-合体"><a href="#RDB-和-AOF-合体" class="headerlink" title="RDB 和 AOF 合体"></a>RDB 和 AOF 合体</h5><p>介绍：redis4.0 提出</p>
<p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<h3 id="Redis过期删除策略和内存淘汰策略"><a href="#Redis过期删除策略和内存淘汰策略" class="headerlink" title="Redis过期删除策略和内存淘汰策略"></a>Redis过期删除策略和内存淘汰策略</h3><h4 id="过期删除策略有哪些？"><a href="#过期删除策略有哪些？" class="headerlink" title="过期删除策略有哪些？"></a>过期删除策略有哪些？</h4><p>在说 Redis 过期删除策略之前，先跟大家介绍下，常见的三种过期删除策略：</p>
<ul>
<li>定时删除；<strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></li>
<li>惰性删除；<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></li>
<li>定期删除；<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></li>
</ul>
<p>Redis使用的是： <strong>「惰性删除+定期删除」这两种策略配和使用</strong></p>
<p>​	</p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>前面说的过期删除策略，是删除已过期的 key，而当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行</p>
<h4 id="Redis-内存淘汰策略有哪些？"><a href="#Redis-内存淘汰策略有哪些？" class="headerlink" title="Redis 内存淘汰策略有哪些？"></a>Redis 内存淘汰策略有哪些？</h4><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p>
<p><em>1、不进行数据淘汰的策略</em></p>
<p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p>
<p><em>2、进行数据淘汰的策略</em></p>
<p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p>
<p>在设置了过期时间的数据中进行淘汰：</p>
<ul>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
<li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li>
<li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
</ul>
<p>在所有数据范围内进行淘汰：</p>
<ul>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li>
<li><strong>llkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li>
</ul>
<h3 id="集群高可用"><a href="#集群高可用" class="headerlink" title="集群高可用"></a>集群高可用</h3><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul>
<li>大量key同时过期</li>
<li>Redis宕机</li>
</ul>
<p>应对方法：</p>
<ul>
<li>均匀设置过期时间，使用随机数设置过期时间</li>
<li>业务对象不再更新缓存，缓存也不设置有效期；将更新缓存的工作交给后台线程；</li>
<li>互斥锁，当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul>
<li>热点key过期</li>
</ul>
<p>应对方法与缓存雪崩一致</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存中没有该数据；</p>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<ul>
<li>第一种方案，非法请求的限制；</li>
<li>第二种方案，缓存空值或者默认值；</li>
<li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_%E7%BC%93%E5%AD%98.png" alt="redis_缓存"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/14/C++%E6%8C%87%E9%92%88%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/14/C++%E6%8C%87%E9%92%88%E7%AF%87/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-14 18:36:58" itemprop="dateCreated datePublished" datetime="2024-04-14T18:36:58+08:00">2024-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-14 23:28:12" itemprop="dateModified" datetime="2024-07-14T23:28:12+08:00">2024-07-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h2 id="title-C-指针篇"><a href="#title-C-指针篇" class="headerlink" title="title:C++指针篇"></a>title:C++指针篇</h2><h1 id="C-指针篇"><a href="#C-指针篇" class="headerlink" title="C++指针篇"></a>C++指针篇</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>本篇基于一定的C++基础进行讲解，基础知识一带而过；</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li>指针存储在哪？<ul>
<li>我们通过new进行结构的初始化，此时会在自由存储空间（堆空间）进行内存分配；</li>
</ul>
</li>
<li>指针存储的值是什么？<ul>
<li>指针本身代表的是内存地址，内存地址上的值则是我们声明的变量；</li>
</ul>
</li>
<li>指针的信息是什么类型？<ul>
<li>指针的类型在C++中我们将其看作是十六进制的int类型（强调：只是看作）</li>
</ul>
</li>
</ul>
<h3 id="指针声明-amp-初始化"><a href="#指针声明-amp-初始化" class="headerlink" title="指针声明&amp;初始化"></a>指针声明&amp;初始化</h3><ul>
<li>demo</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">People</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ptr1 为指针类型，ptr2为int类型</span></span><br><span class="line">    <span class="type">int</span> *ptr1, ptr2;</span><br><span class="line">    </span><br><span class="line">    People p = <span class="keyword">new</span> <span class="built_in">People</span>(<span class="string">&quot;Rock&quot;</span>,<span class="number">25</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 裸指针必须释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明&amp;初始化</li>
</ul>
<p><code>int * ptr</code></p>
<p>*注意：在我们声明指针时一定要对指针初始化，否则后续对指针的赋值可能是非预期的结果；</p>
<p><code>int * ptr = new int</code></p>
<h3 id="数组的静态联编和动态联编"><a href="#数组的静态联编和动态联编" class="headerlink" title="数组的静态联编和动态联编"></a>数组的静态联编和动态联编</h3><p>静态联编，顾名思义为程序静态编译时的行为；</p>
<p>int number[10] ;</p>
<p>动态联编, 程序动态运行时进行的操作；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; size;</span><br><span class="line"><span class="type">int</span> * ptr = <span class="keyword">new</span> <span class="type">int</span>[size] ;</span><br><span class="line"><span class="comment">// 等价于*ptr = 1;</span></span><br><span class="line">ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">*(ptr + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>



<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><ul>
<li>自动存储，静态存储，动态存储；</li>
</ul>
<p>自动存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    int number = 1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码闭包中的零时变量都是自动存储类型，当函数或闭包结束时零时变量将依次释放；</p>
<p>静态存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> number;</span><br></pre></td></tr></table></figure>

<p>静态存储为全局变量，当使用static活着在函数外部定义时定义，静态变量将贯穿整个程序的生命周期；</p>
<p>动态存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * ptr = <span class="keyword">new</span> <span class="type">int</span> </span><br></pre></td></tr></table></figure>

<p>动态变量使用new进行初始化的变量，创建在堆区（自由存储区），动态存储变量需要使用delete进行删除，他不会随着函数或闭包的结束而释放；因此当出现使用new进行初始化的变量时，应该使用delete进行内存释放，否则会出现内存泄漏问题；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/26/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/26/Mysql/" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-26 22:24:54" itemprop="dateCreated datePublished" datetime="2023-12-26T22:24:54+08:00">2023-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-14 10:25:53" itemprop="dateModified" datetime="2024-07-14T10:25:53+08:00">2024-07-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mysql-基础"><a href="#Mysql-基础" class="headerlink" title="Mysql 基础"></a>Mysql 基础</h1><h2 id="Mysql架构"><a href="#Mysql架构" class="headerlink" title="Mysql架构"></a>Mysql架构</h2><p>Mysql主要分为三层，客户层，server层，存储引擎层（存储引擎层提供接口用于数据读写接口）</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/MySql_arch.png" alt="image-20240630231048538"></p>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><ul>
<li>一种能帮助mysql提高了查询效率的数据结构：<strong>索引数据结构</strong>。</li>
</ul>
<h3 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h3><p>索引的存储原理大致可以概括为一句话：<strong>以空间换时间</strong>。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此<code>索引往往是存储在磁盘上的文件中的</code>（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</p>
<p>数据库在未添加索引进行查询的时候默认是进行全文搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕。</p>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul>
<li><p>主键索引：primary key </p>
<ul>
<li>设定主键后，数据库自动建立的索引，innoDb引擎为聚簇索引；</li>
</ul>
</li>
<li><p>普通索引</p>
<ul>
<li>mysql中的基础索引类型，没有什么限制，允许在索引列插入NULL</li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li>索引列的值必须唯一</li>
</ul>
</li>
<li><p>复合索引</p>
<ul>
<li>一个索引可以包含多个列，多个列共同构成一个复合索引</li>
</ul>
</li>
<li><p>前缀索引</p>
<ul>
<li>使用BLOG，TEXT，长类型varchar类型时可以使用前缀索引；</li>
</ul>
</li>
<li><p>全文索引</p>
<ul>
<li>char，varchar上的全文查找</li>
</ul>
</li>
<li><p>空间索引</p>
</li>
</ul>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>Mysql索引有两大数据结构：</p>
<ul>
<li>B+ Tree </li>
<li>hash</li>
</ul>
<p>对于大部分单条查询hash索引即可满足查询性能，其余的建议使用B+树</p>
<h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>hash表介绍</p>
<p>  我们使用hash表存储表数据结构，<strong>Key可以存储索引列，Value可以存储行记录或者行磁盘地址</strong>。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时只能通过扫描全表的方式，筛选出符合条件的数据。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p><code> 聚簇索引不是一种索引类型，而是一种数据存储方式</code></p>
<p><strong>介绍</strong>:</p>
<ul>
<li><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p>
</li>
<li><p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p>
</li>
</ul>
<p><strong>澄清一个概念</strong>：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</p>
<ul>
<li><p>聚簇索引的演变：</p>
<ul>
<li><p>二叉树</p>
<ul>
<li>当二叉树插入的数据都是大于前一个数据时会成为一链表结构，即为线性树；</li>
</ul>
</li>
<li><p>平衡二叉树</p>
<ul>
<li>每次插入时会判断<strong>每个节点的左子树和右子树的高度差不能超过 1</strong></li>
<li>但是当插入元素过多时会出现树的高度过大的问题；</li>
</ul>
</li>
<li><p>B树</p>
<ul>
<li>允许一个节点可以有两个以上的子叶子节点；</li>
<li>但是做范围查询时需要使用中序遍历，设计多个节点的磁盘I&#x2F;O</li>
</ul>
</li>
<li><p>B+树</p>
<ul>
<li>最底部存放的不再只是索引，而是存储索引+数据</li>
<li>最底部的叶子节点之间形成有序链表</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B.png" alt="image-20240630232608169"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将<strong>主键组织到一棵B+树</strong>中，而<strong>行数据就储存在叶子节点</strong>上，若使用”where id &#x3D; 14”这样的条件查找主键，则<strong>按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据</strong>。</li>
<li>若<strong>对Name列进行条件搜索，则需要两个步骤</strong>：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</strong>。第二步<strong>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</strong>。（<strong>重点在于通过其他键需要建立辅助索引</strong>）</li>
</ol>
<p><strong>聚簇索引的误区</strong></p>
<ul>
<li><strong>把主键自动设为聚簇索引</strong>： 聚簇索引具有唯一性，且性能最好；因此设置聚簇索引时我们必须谨慎设置；</li>
<li><strong>聚簇索引需要两次B+树查找效率看起来”更低”：</strong><ul>
<li>首先明确聚簇索引的使用场景：插入较少（当使用uuid作为主键时会导致数据插入到之前记录的中间，需要强制移动之前的记录，因此大量新行插入不适用），建议使用自增id作用主键（前面场景说到聚簇索引需要谨慎，实际上生活中也存在顺序主键比如：学号，班级等），这时主键页会按照顺序填满；</li>
<li>适合使用在排序的场景，因为相邻数据放在一起（同一页中），I&#x2F;O次数更少</li>
</ul>
</li>
</ul>
<p><strong>聚簇索引也有缺点</strong></p>
<ul>
<li>维护索引开销大：<strong>特别是插入新行或者主键被更新导至要分页(page split)的时候</strong>；</li>
<li>表因为使用UUId（随机ID）作为主键，使数据存储稀疏；</li>
</ul>
<h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ol>
<li><p><strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
</li>
<li><p><strong>&#x3D;和in可以乱序</strong>，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
</li>
<li><p><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p>
</li>
<li><p><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’)。</p>
</li>
<li><p><strong>尽量的扩展索引</strong>，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
</li>
</ol>
<h1 id="MySQL-问题调优"><a href="#MySQL-问题调优" class="headerlink" title="MySQL 问题调优"></a>MySQL 问题调优</h1><h2 id="SQL卡死"><a href="#SQL卡死" class="headerlink" title="SQL卡死"></a>SQL卡死</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><pre><code>客户私有化环境中执行sql文件时卡死，从现象上看是卡死在某一个语句，单独拿出来依然无法执行；从私有化环境中导出到开发环境执行，成功通过；初步怀疑是环境问题，从docker环境中新建一个相同的镜像环境，执行依然成功；问题卡住；
我们从头开始分析：
1、执行explain未发现问题
2、执行show full proceelist 发现没有连接；
此时还没发现问题，以为是卡在了语法解析阶段（因为sql特别大有7、8M）；
后重新使用docker环境执行show full processlist 发现docker 上居然有！此时怀疑客户私有化环境上没连上server端，怀疑代理问题；让客户直连mysql，执行成功！！
以上问题主要是对mysql的执行过程不太熟练导致，因此一下补充mysql执行过程已经mysql架构等知识；
</code></pre>
<h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><p>mysql架构分为以下三层</p>
<ul>
<li>客户端服务层：客户端服务层主要完成鉴权，链接处理，授权认证；</li>
<li>核心服务层： 核心服务层包含链接线程池，查询解析，分析，优化，缓存，内置函数等；一切mysql的处理都在核心服务层；</li>
<li>存储引擎层：负责mysql的存储以及提取；</li>
</ul>
<h3 id="sql语句执行分析"><a href="#sql语句执行分析" class="headerlink" title="sql语句执行分析"></a>sql语句执行分析</h3><ul>
<li><p>万能的Explain（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html%EF%BC%89">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html）</a></p>
<ul>
<li>explain select * from table where Id&#x3D;1；</li>
<li>explain 展示字段：</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>    <span class="operator">|</span> Extra       <span class="operator">|</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>processlist mysql server端中的连接；</p>
<ul>
<li>show full processlist</li>
</ul>
</li>
</ul>
<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><h2 id="Mysql基础函数"><a href="#Mysql基础函数" class="headerlink" title="Mysql基础函数"></a>Mysql基础函数</h2><ul>
<li><code>mysql</code> 中的各种调用函数，常用的时间转换函数</li>
</ul>
<h2 id="str-to-date-时间转换函数"><a href="#str-to-date-时间转换函数" class="headerlink" title="str_to_date 时间转换函数"></a><code>str_to_date</code> 时间转换函数</h2><p>在<code>mysql</code>中<code>str_to_date</code>函数是一个非常有用的函数，能够将字符串转换为日期格式；</p>
<ul>
<li><code>str_to_date(&#39;str&#39;,&#39;model&#39;)</code>;其中<code>model</code>是转换的格式<code>%Y-%m-%d %H:%i:%s</code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 示例：</span><br><span class="line">update saas_smart_list_content set startTime = STR_TO_DATE(&#x27;2022-04-01 17:46:38&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;) where startTime = STR_TO_DATE(&#x27;0000-00-00 00:00:00&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;) limit 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from saas_smart_list_content where startTime &lt;= STR_TO_DATE(&#x27;2022-04-01 17:46:38&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;) limit 1;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/redis/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-22 22:37:36 / 修改时间：22:46:33" itemprop="dateCreated datePublished" datetime="2023-08-22T22:37:36+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis-综述"><a href="#Redis-综述" class="headerlink" title="Redis 综述"></a>Redis 综述</h1><h2 id="Redis-基础数据结构"><a href="#Redis-基础数据结构" class="headerlink" title="Redis 基础数据结构"></a>Redis 基础数据结构</h2><p>redis 有五种基本的数据结构，其中我们常用的又<code>string</code>类型，<code>list</code>类型，<code>set</code>类型，<code>zset</code>类型，<code>hash</code> 类型；另外还有其他的数据类型包含<code>geo</code>数据类型，用于计算经纬度指标；<code>hyperloglogs</code>用于不太精准的计数，常常用于网页活跃人数统计；BitMaps位操作数据类型；</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/pprof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/pprof/" class="post-title-link" itemprop="url">Go pprof</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 11:32:01" itemprop="dateCreated datePublished" datetime="2023-08-22T11:32:01+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Go pprof 可以让你清晰的知道,运行中程序是如何运行,此刻他又在经历些什么</p>
<p>我们由简入深,先知道如何使用他,再深入的了解他的功能,带入到实践当中</p>
</blockquote>
<h1 id="Go-pprof-的使用"><a href="#Go-pprof-的使用" class="headerlink" title="Go pprof 的使用"></a>Go pprof 的使用</h1><p>当我们分析不同的内容时，我们需要使用到的文件也不同；</p>
<ul>
<li>cpu（CPU Profiling）: <code>/debug/pprof/profile</code>，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件</li>
<li>block（Block Profiling）：<code>/debug/pprof/block</code>，查看导致阻塞同步的堆栈跟踪</li>
<li>goroutine：<code>/debug/pprof/goroutine</code>，查看当前所有运行的 goroutines 堆栈跟踪</li>
<li>heap（Memory Profiling）: <code>/debug/pprof/heap</code>，查看活动对象的内存分配情况</li>
<li>mutex（Mutex Profiling）：<code>/debug/pprof/mutex</code>，查看导致互斥锁的竞争持有者的堆栈跟踪</li>
<li>threadcreate：<code>/debug/pprof/threadcreate</code>，查看创建新OS线程的堆栈跟踪</li>
</ul>
<p>1、按照可视化工具<code>graphviz</code></p>
<pre><code> 如果我们想要生成可视图,则需要安装 ` brew install graphviz`
</code></pre>
<p>2、生成分析文件	</p>
<p>​	<code>Go pprof</code> 首先需要代码，引入了<code>net/http/pprof</code> ,通常来说,各种GoWeb框架会自带,例如字节的<code>Kitex</code>框架等; 如果代码中引入了<code>net/http/pprof</code>则无需进行其他操作;直接执行以下命令，若没有引用，则无法使用<code>pprof</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weget http://127.0.0.1:80/pprof/profile</span><br></pre></td></tr></table></figure>

<p>3、查看文件内容	</p>
<p>​	执行上述操作后,会下载一个<code>profile</code>文件,我们下载到本地后使用 <code>go tool pprof filename</code> 查看内容;将<code>profile</code>文件下载后,执行<code>go tool pprof profile</code>即可查看内容；同时我们也可以执行<code>go tool pprof -http=:8080 profile</code>生成可视化界面,点击左上角的View即可查看火焰图;</p>
<p>以上命令总结:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用go tool 工具在线看</span><br><span class="line">go tool pprof profile</span><br><span class="line"># 使用web页面查看火焰图等可视化图</span><br><span class="line">go tool pprof -http=:8080 profile</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/uPic/image-20230628232558050.png" alt="image-20230628232558050"></p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/uPic/image-20230628231851925.png" alt="image-20230628231851925"></p>
<p>​	进入到命令页面之后,我们执行<code>top20</code>,打印消耗排名前20, 同时也可以输入<code>web</code>进入页面查看;</p>
<h1 id="pprof-指标的含义"><a href="#pprof-指标的含义" class="headerlink" title="pprof 指标的含义"></a>pprof 指标的含义</h1><h2 id="flat-flat"><a href="#flat-flat" class="headerlink" title="flat flat%"></a>flat flat%</h2><p>flat:  代表一个函数内的directly操作的耗时</p>
<p>flat:  代表flat&#x2F;总的运行时间,所有的flat相加即为总时间  </p>
<ul>
<li>directly 操作代表函数内部的CPU直接调用，若是调用其他函数等操作则不是directly操作；</li>
<li>flat越大，代表这个函数的cpu处理较多</li>
</ul>
<h2 id="cum-cum"><a href="#cum-cum" class="headerlink" title="cum cum%"></a>cum cum%</h2><p>cum:  代表一个函数内所有物理操作的耗时</p>
<p>cum:  代表cum&#x2F;总的运行时间</p>
<ul>
<li>cum越高代表某个函数执行的时间越长，此函数的性能越低；</li>
</ul>
<h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p>sum代表以上行所有flat相加</p>
<h1 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h1><p>火焰图分为两种：on_cpu, off_cpu</p>
<table>
<thead>
<tr>
<th>火焰图类型</th>
<th>横轴含义</th>
<th>纵轴含义</th>
<th>解决问题</th>
<th>采样方式</th>
</tr>
</thead>
<tbody><tr>
<td>cpu火焰图</td>
<td>cpu占用时间</td>
<td>调用栈</td>
<td>找出cpu占用高的问题函数，分析代码热路径；</td>
<td>固定频率采样cpu调用栈；</td>
</tr>
<tr>
<td>off-cpu火焰图</td>
<td>阻塞时间</td>
<td>调用栈</td>
<td>i&#x2F;o、网络等阻塞场景导致的性能下降；竞争锁，死锁导致的性能下降问题；</td>
<td>固定频率采样阻塞事件调<br/>用栈</td>
</tr>
<tr>
<td>内存火焰图</td>
<td>内存申请&#x2F;释放函数调用次数</td>
<td>调用栈</td>
<td>内存泄露问题；内存占用高的对用象&#x2F;申请内存多的函数；虚拟内存栈或物理内存泄露问题；</td>
<td>跟踪调用栈</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/prometheus/client_go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/prometheus/client_go/" class="post-title-link" itemprop="url">prometheus/client_go</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 11:32:01" itemprop="dateCreated datePublished" datetime="2023-08-22T11:32:01+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="prometheus-go-client-内存持续上涨"><a href="#prometheus-go-client-内存持续上涨" class="headerlink" title="prometheus go client 内存持续上涨"></a>prometheus go client 内存持续上涨</h1><h2 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h2><ul>
<li>网关层服务增加prometheus client 之后内存上涨10GB，造成内存报警；</li>
</ul>
<h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><p>​	增加prometheus client 之后内存上涨是在预料之内的事情，但上涨幅度达到10GB，超出预估范围100%以上！起初分析原因是因为一些未知的错误增加到detail label 上导致，比如json解析失败时，不同的字符错误会输出不同的错误类型，而世界上已知字符数量为120W！指标无限扩大！但是查询指标内容之后，发现err错误只占指标的一小部分，但依然是一个隐患，因此label的内容应该固定在指定数量以内。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">globalHttpClientHandledCounter = prom.NewCounterVec(</span><br><span class="line">		prom.CounterOpts&#123;</span><br><span class="line">			Name: <span class="string">&quot;arch_http_client_throughput&quot;</span>,</span><br><span class="line">			Help: <span class="string">&quot;Total number of http completed by the client, regardless of success or failure.&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		[]<span class="type">string</span>&#123;labelKeyServiceId, labelKeyOrganization, labelKeyCode, labelKeyHttpCode, labelKeyInnerCode, labelKeyCaller, labelKeyAppid, labelKeyOrg  ,labelKeyCallee, labelKeyDetail, labelKeyUrl, labelKeyStatus, labelKeyRetry&#125;,</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>



<p>​	继续分析原因，以上代码中，我们发现 appid&amp;org 维度有上万个不同的类型，因此可能导致维度散发从而造成数据大爆炸，Appid有1W以上不同值，Org有1K以上不同的值，因此维度相乘之后造成了数据大爆炸；因此后续我们将AppId与Org维度下线后，内存上涨幅度缩减为之前的十分之一，但这与我们预估的MB级别内存波动依然有一定差异；同时观察发现，内存在持续小幅度上涨；</p>
<p>​    <img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/uPic/image-20230523113607597.png" alt="image-20230523113607597"></p>
<p>​	</p>
<h3 id="内存持续上涨"><a href="#内存持续上涨" class="headerlink" title="内存持续上涨"></a>内存持续上涨</h3><p>​	首先解决第一个问题内存持续上涨的原因，在预期中我们预期希望的应该是当prometheus采集时，能够拿到当前有效的信息即可，不需要无效内容，比如某个公司的QPS从五天前就一直是零，那么我们认为这是一个无效数据；所以我们使用Client_golang希望采集的应该是当前的实时数据；</p>
<p>​	而实际情况是，当我们在prometheus上删除某个label时，client端依然存在；查看client_golang源码发现，prometheus client 并没有显示的去调用删除；因此指标将会一直存在内存当中，这也是导致内存会持续上涨的原因之一。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/uPic/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_9e3ca4f4-d2c6-4943-82d9-87573ab534d8.png" alt="企业微信截图_9e3ca4f4-d2c6-4943-82d9-87573ab534d8"></p>
<h3 id="内存膨胀"><a href="#内存膨胀" class="headerlink" title="内存膨胀"></a>内存膨胀</h3><p>​	第二个问题为什么在删除AppId&amp;Org两个大范围的维度之后，内存波动依然会达到 1GB 上下？观察</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/Apollo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/Apollo/" class="post-title-link" itemprop="url">Apollo Config</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 11:32:01" itemprop="dateCreated datePublished" datetime="2023-08-22T11:32:01+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Apollo-Config"><a href="#Apollo-Config" class="headerlink" title="Apollo Config"></a>Apollo Config</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 11:32:01" itemprop="dateCreated datePublished" datetime="2023-08-22T11:32:01+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><p> 拉取镜像</p>
<ul>
<li>docker pull mysql:tag</li>
</ul>
<p>查看镜像</p>
<ul>
<li>docker ps</li>
</ul>
<p>运行镜像</p>
<ul>
<li>docker run -d —name <xxx> -p <localPort>:<dockerPort>  dockerName:tag<ul>
<li><ul>
<li>it 交互式运行</li>
</ul>
</li>
<li><ul>
<li>d 后台运行</li>
</ul>
</li>
<li><ul>
<li>v 挂载数据卷</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>进入已运行的容器</p>
<ul>
<li>docker exec -it <CONTAINER> bash</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/Go%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">Go 八股文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-22 11:29:03 / 修改时间：11:32:01" itemprop="dateCreated datePublished" datetime="2023-08-22T11:29:03+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>八股文，不背不行，背了也不行</p>
<h1 id="Go基础知识"><a href="#Go基础知识" class="headerlink" title="Go基础知识"></a>Go基础知识</h1><h2 id="Make-amp-New的区别"><a href="#Make-amp-New的区别" class="headerlink" title="Make&amp;New的区别"></a>Make&amp;New的区别</h2><h3 id="New"><a href="#New" class="headerlink" title="New"></a>New</h3><ul>
<li>分配内存，内存里存的值是零值。</li>
<li>只有一个参数，参数是分配的内存空间。</li>
<li>Go语音里任何参数都可以是New的参数，如int，数组，结构体，函数类型都可以。</li>
<li>返回的是指针</li>
</ul>
<h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><ul>
<li>分配和初始化内存</li>
<li>只能用于slice，map，chan</li>
<li>返回原始类型，例如slice</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>) <span class="comment">// 返回的类型是[]int</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-22 11:29:03 / 修改时间：11:36:19" itemprop="dateCreated datePublished" datetime="2023-08-22T11:29:03+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p>一、配置config.yml文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:yiwenqi/yiwenqi.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>二、执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="How-to-use-hex"><a href="#How-to-use-hex" class="headerlink" title="How to use hex"></a>How to use hex</h1><p>一、从github仓库拉去代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:yiwenqi/BLOG.git</span><br></pre></td></tr></table></figure>

<p>二、执行以下命令重新部署</p>
<p>1、hexo clean<br>2、hexo g<br>3、hexo d</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
