<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/24/%E9%9D%A2%E8%AF%95&%E5%B7%A5%E4%BD%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/24/%E9%9D%A2%E8%AF%95&%E5%B7%A5%E4%BD%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">面试&工作基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-24 00:02:11" itemprop="dateCreated datePublished" datetime="2024-07-24T00:02:11+08:00">2024-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-29 10:36:48" itemprop="dateModified" datetime="2024-07-29T10:36:48+08:00">2024-07-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="线程与协程之间的区别"><a href="#线程与协程之间的区别" class="headerlink" title="线程与协程之间的区别"></a>线程与协程之间的区别</h2><p>定义：	</p>
<ul>
<li>进程：是具有独立功能的程序，系统资源分配和独立运行的最小单元；</li>
<li>线程：线程是进程一个执行单元，是任务调度与执行的最小单元；</li>
<li>协程：轻量级别的线程，是一种用户态的线程；</li>
</ul>
<p>区别：</p>
<ul>
<li>线程是任务调度的基本单元，进程是资源分配的最小单元</li>
<li>包含关系：一个进程可以有多个线程，但至少有一个线程。</li>
<li>资源关系：同类的线程共享线程的堆和方法区资源，但每个线程有自己的程序计数器，虚拟机栈，本地方法栈；进程之间的地址空间和资源是独立的；</li>
<li>影响关系：进程之间是受保护的，一个进程崩溃不会影响另外一个进程；线程崩溃会导致进程也崩溃</li>
</ul>
<h2 id="协程为什么比线程快"><a href="#协程为什么比线程快" class="headerlink" title="协程为什么比线程快"></a>协程为什么比线程快</h2><p>1、<strong>协程切换比线程的开销更小</strong>: 	<strong>线程之间的切换涉及到内核态和用户态的转换</strong>，这就需要消耗大量CPU资源，而协程就是在用户态上进行的；</p>
<p>2、<strong>执行效率更高</strong>:    由于协程是用户态下的执行单元，它的<strong>执行不会受到操作系统的调度影响</strong>。这意味着，当一个协程在执行一个耗时操作（如I&#x2F;O操作）时，它不会被操作系统打断，而是可以充分利用CPU资源进行计算，从而提高了执行效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/23/MySql%E5%8D%83%E4%B8%87%E7%BA%A7%E5%88%AB%E6%95%B0%E6%8D%AE%E6%96%B0%E5%A2%9E%E5%AD%97%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/23/MySql%E5%8D%83%E4%B8%87%E7%BA%A7%E5%88%AB%E6%95%B0%E6%8D%AE%E6%96%B0%E5%A2%9E%E5%AD%97%E6%AE%B5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-23 23:10:51 / 修改时间：23:25:17" itemprop="dateCreated datePublished" datetime="2024-07-23T23:10:51+08:00">2024-07-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySql-千万级别数据新增字段"><a href="#MySql-千万级别数据新增字段" class="headerlink" title="MySql 千万级别数据新增字段"></a>MySql 千万级别数据新增字段</h1><h2 id="MySQL-大表数据添加新字段"><a href="#MySQL-大表数据添加新字段" class="headerlink" title="MySQL 大表数据添加新字段"></a><strong>MySQL 大表数据添加新字段</strong></h2><p>​	直接添加会导致<code>mysql</code>卡死,同时命令执行超时；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table product_table add column column_name varchar(32) default &quot;&quot; </span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>一、扩展新表</p>
<h5 id="扩展新表方案"><a href="#扩展新表方案" class="headerlink" title="扩展新表方案"></a><strong>扩展新表方案</strong></h5><blockquote>
<p>创建一个新表<code>user_ext(id,user_id,flag)</code>,将<code>user</code>表的id导入<code>user_ext</code>,然后<code>user</code>表和<code>user_ext</code>通过关联就可以间接实现我们的需求。</p>
</blockquote>
<p>二、新建一张表</p>
<blockquote>
<p>创建一个临时的新表，首先复制旧表的结构（包含索引）</p>
</blockquote>
<blockquote>
<p>给新表加上新增的字段</p>
</blockquote>
<blockquote>
<p>把旧表的数据复制过来</p>
</blockquote>
<blockquote>
<p>删除旧表，重命名新表的名字为旧表的名字</p>
</blockquote>
<p>*建议在脱机情况下操作，防止数据不完整；</p>
<p>三、升级Mysql版本到8.0以上</p>
<p>总结：</p>
<ul>
<li>若是在线上添加则可以进行如下方案:<ul>
<li>数据不大：直接天机</li>
<li>数据大：使用pt_osc添加（percona tools 专用与线上数据结构定义的修改工具）</li>
<li>数据大，且是热表：先在从库添加 再进行主从切换</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/16/algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/16/algorithm/" class="post-title-link" itemprop="url">常用算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-16 11:45:09" itemprop="dateCreated datePublished" datetime="2024-07-16T11:45:09+08:00">2024-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-02 09:12:01" itemprop="dateModified" datetime="2024-08-02T09:12:01+08:00">2024-08-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="快排原理-分治思想"><a href="#快排原理-分治思想" class="headerlink" title="快排原理-分治思想"></a>快排原理-分治思想</h2><p>​	快排的基本思想是<strong>分而治之</strong>：首先使用双指针在两边，同时选择<strong>指针中间的任意一个数据作为基准点</strong>，大于基准点的放右边，小于基准点的放左边；</p>
<p>直到基准点左边都比基准点小，右边都比基准点大；再进行递归计算；</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/%E5%BF%AB%E6%8E%92.png" alt="快排"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">33</span>, <span class="number">101</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">91</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">20</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	quickSort(arr)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(array []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> array</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择中间作为基准值</span></span><br><span class="line">	left, right := <span class="number">0</span>, <span class="built_in">len</span>(array)<span class="number">-1</span></span><br><span class="line">	pivot := array[(left+right)/<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分区操作</span></span><br><span class="line">	<span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">		<span class="keyword">for</span> array[left] &lt; pivot &#123;</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> array[right] &gt; pivot &#123;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此处必须是等于，当在最后一次循环时，若不是 == ，则会一直卡在最后一次循环；left，right无法退出；</span></span><br><span class="line">		<span class="keyword">if</span> left &lt;= right &#123;</span><br><span class="line">			array[left], array[right] = array[right], array[left]</span><br><span class="line">			left++</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归排序</span></span><br><span class="line">	<span class="keyword">if</span> right &gt; <span class="number">0</span> &#123;</span><br><span class="line">		quickSort(array[:right+<span class="number">1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> left &lt; <span class="built_in">len</span>(array) &#123;</span><br><span class="line">		quickSort(array[left:])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯思想"><a href="#回溯思想" class="headerlink" title="回溯思想"></a>回溯思想</h2><h3 id="全排列算法"><a href="#全排列算法" class="headerlink" title="全排列算法"></a>全排列算法</h3><p>问题：列出一个数组中元素的所有排列组合；eg: []int{1,2,3}</p>
<ul>
<li>[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%9E%E6%BA%AF%E6%80%9D%E6%83%B3.png" alt="全排列-回溯思想"></p>
<p>示例代码：全排列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	res, path = <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	st = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	</span><br><span class="line">	Dfs(nums, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dfs</span><span class="params">(nums []<span class="type">int</span>, cur <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">	<span class="comment">// 退出条件 当遍历位置为最后一个索引时</span></span><br><span class="line">	<span class="keyword">if</span> cur == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">		<span class="built_in">copy</span>(tmp, path)</span><br><span class="line">		res = <span class="built_in">append</span>(res, path)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !st[i] &#123;</span><br><span class="line">			<span class="comment">//fmt.Println(&quot;i:&quot;, i)</span></span><br><span class="line">			fmt.Println(path)</span><br><span class="line">			path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">            <span class="comment">// 标记当前位置已经被占用</span></span><br><span class="line">			st[i] = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 递归下一个位置</span></span><br><span class="line">			Dfs(nums, cur+<span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 递归结束，回溯，将上一个位置释放</span></span><br><span class="line">			st[i] = <span class="literal">false</span></span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	res  []<span class="type">string</span></span><br><span class="line">	path []<span class="type">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IpDfs</span><span class="params">(ipSegment <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// path == 3 则无需继续切分</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> v, ok := strconv.Atoi(ipSegment); ok != <span class="literal">nil</span> &amp;&amp; v &gt; <span class="number">255</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(ipSegment) &lt;= <span class="number">3</span> &#123;</span><br><span class="line">			ipAdd := strconv.Itoa(path[<span class="number">0</span>])</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(path); i++ &#123;</span><br><span class="line">				v := strconv.Itoa(path[i])</span><br><span class="line">				ipAdd += <span class="string">&quot;.&quot;</span> + v</span><br><span class="line">			&#125;</span><br><span class="line">            ipAdd += <span class="string">&quot;.&quot;</span> + ipSegment</span><br><span class="line">			res = <span class="built_in">append</span>(res, ipAdd)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回溯</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 获取ip</span></span><br><span class="line">		ipStr := ipSegment[:i+<span class="number">1</span>]</span><br><span class="line">		v, ok := strconv.Atoi(ipStr)</span><br><span class="line">		<span class="keyword">if</span> ok != <span class="literal">nil</span> || v &gt; <span class="number">255</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		path = <span class="built_in">append</span>(path, v)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 截断：ipSegment[0:1]</span></span><br><span class="line">		tmpIp := ipSegment[i+<span class="number">1</span>:]</span><br><span class="line">		IpDfs(tmpIp)</span><br><span class="line">		path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h4><p>​	LRU缓存（最近最少使用）数据结构，使用一个 <code>HashMap</code> 进行O(1)的查询，并使用双向链表作为数据存储结构；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	Capacity   <span class="type">int</span></span><br><span class="line">	Size       <span class="type">int</span></span><br><span class="line">	Head, Tail *DLinkedNode</span><br><span class="line">	cache      <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Prev, Next *DLinkedNode</span><br><span class="line">	Key, Value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDLinkedNode</span><span class="params">()</span></span> *DLinkedNode &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">		Prev: <span class="literal">nil</span>,</span><br><span class="line">		Next: <span class="literal">nil</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">	l := LRUCache&#123;</span><br><span class="line">		Capacity: capacity,</span><br><span class="line">		Head:     initDLinkedNode(),</span><br><span class="line">		Tail:     initDLinkedNode(),</span><br><span class="line">		cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode),</span><br><span class="line">	&#125;</span><br><span class="line">	l.Head.Next = l.Tail</span><br><span class="line">	l.Tail.Prev = l.Head</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> MoveToHead(node *DLinkedNode) <span class="type">bool</span> &#123;</span><br><span class="line">	this.removeNode(node)</span><br><span class="line">	this.AddToHead(node)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;</span><br><span class="line">	node.Prev.Next = node.Next</span><br><span class="line">	node.Next.Prev = node.Prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> AddToHead(node *DLinkedNode) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 移动到head head.next =&gt; tmp head.next = node,</span></span><br><span class="line"><span class="comment">	tmp.pre =&gt; node, node.pre =&gt; head, node.next = tmp</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	node.Prev = this.Head</span><br><span class="line">	node.Next = this.Head.Next</span><br><span class="line">	this.Head.Next.Prev = node</span><br><span class="line">	this.Head.Next = node</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeTail() *DLinkedNode &#123;</span><br><span class="line">	node := this.Tail.Prev</span><br><span class="line">	this.removeNode(node)</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 判断是否存在</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断value是否为nil</span></span><br><span class="line">	node := this.cache[key]</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将node移动至头指针</span></span><br><span class="line">	ok := this.MoveToHead(node)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> node.Value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> _, ok := this.cache[key]; !ok &#123;</span><br><span class="line">		node := initDLinkedNode()</span><br><span class="line">		node.Key = key</span><br><span class="line">		node.Value = value</span><br><span class="line">		this.cache[key] = node</span><br><span class="line">		this.AddToHead(node)</span><br><span class="line">		this.Size++</span><br><span class="line">		<span class="keyword">if</span> this.Size &gt; this.Capacity &#123;</span><br><span class="line">			removed := this.removeTail()</span><br><span class="line">			<span class="built_in">delete</span>(this.cache, removed.Key)</span><br><span class="line">			this.Size--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		node := this.cache[key]</span><br><span class="line">		node.Value = value</span><br><span class="line">		this.MoveToHead(node)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>堆的定义</strong>：</p>
<ul>
<li>堆是一个完全二叉树（完全二叉树，所有节点被子节点填满，子节点从左向右填）</li>
<li>堆上的每个节点的值必须大于或等于（或小于, 小堆顶为小于）其子树中的每个节点值；</li>
</ul>
<p><strong>堆的存储</strong>：</p>
<ul>
<li>堆是一个完全二叉树，因此可以使用数组来存储；连续的空间更加节省内存；</li>
</ul>
<p><strong>堆的几个关键公式</strong>：第一个元素从下标1 开始；</p>
<p><code>i  </code>  代表节点下标索引,<code>n  </code>  代表节点个数；</p>
<ul>
<li><code>2i </code> 为其左节点， <code>2i+1</code>为其右节点下标；<code>i/2</code>为其父节点；</li>
<li>所有的叶子节点下标范围：<code>n/2 + 1 ~ n</code></li>
</ul>
<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>1、堆化</p>
<p>​	当我们有一个堆时，需要往堆插入元素，此时将元素插入数组的末尾，此时不满足堆的子节点比堆小的条件，此时堆需要进行调整，这个调整的过程就是堆化；</p>
<p>​	堆化分为：自下而上和自上而下；先说自上而下，将第 i 个元素依次与叶子节点比较，选择最大元素，交换第 i 个元素与最大元素之间的位置，然后继续比较该元素与其所在叶子节点之间的大小， 循环执行，直到该元素比其叶子节点大；</p>
<p>heapify: 从父节点，左子节点，右子节点之间选择最大的元素作为他们的root；循环执行直到其元素大于等于其叶子节点；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Heapify</span><span class="params">(a []<span class="type">int</span>, n <span class="type">int</span>, index <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		maxIndex := index</span><br><span class="line">		<span class="keyword">if</span> <span class="number">2</span>*index &lt; n &amp;&amp; a[maxIndex] &lt; a[<span class="number">2</span>*index] &#123;</span><br><span class="line">			maxIndex = <span class="number">2</span> * index</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="number">2</span>*index+<span class="number">1</span> &lt; n &amp;&amp; a[maxIndex] &lt; a[<span class="number">2</span>*index+<span class="number">1</span>] &#123;</span><br><span class="line">			maxIndex = <span class="number">2</span>*index + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> maxIndex == index &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		swap(a, index, maxIndex)</span><br><span class="line">		index = maxIndex</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BuildHeap: 构建堆，由于其叶子节点无需堆化，因此只需要依次对 <code>2*n ~ 1</code>元素下标进行堆化即可；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a []<span class="type">int</span>, index <span class="type">int</span>, maxpos <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	tmp := a[index]</span><br><span class="line">	a[index] = a[maxpos]</span><br><span class="line">	a[maxpos] = tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildHeap</span><span class="params">(a []<span class="type">int</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">		Heapify(a, n, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert 自下而上的堆化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(a []<span class="type">int</span>, n, val <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a)<span class="number">-1</span> &gt;= n &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	a = <span class="built_in">append</span>(a, val)</span><br><span class="line">	pos := <span class="built_in">len</span>(a)</span><br><span class="line">	<span class="keyword">for</span> i := pos / <span class="number">2</span>; i &gt;= <span class="number">1</span>; &#123;</span><br><span class="line">		<span class="keyword">if</span> a[i] &lt; a[i*<span class="number">2</span>] &#123;</span><br><span class="line">			swap(a, i, pos)</span><br><span class="line">		&#125;</span><br><span class="line">		i = i / <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h3><h4 id="合并多个有序文件"><a href="#合并多个有序文件" class="headerlink" title="合并多个有序文件"></a>合并多个有序文件</h4><p>维护一个堆，从多个小文件中获取一个字符串到堆中（有序的文件，因此字符串也是排序之后的），将堆顶元素写入大文件中，继续从刚刚拿到字符串的文件中取下一个字符串；直到所有字符串排序；</p>
<h4 id="大数据量（10亿）求topK"><a href="#大数据量（10亿）求topK" class="headerlink" title="大数据量（10亿）求topK"></a>大数据量（10亿）求topK</h4><p>将10亿数据进行分片，每个文件包含1亿的数据；依次堆小文件进行topk排序，获取每个小文件的topk；然后用这些小文件的topk重新组织一个堆，获取前K个数据；就是这10亿数据的topK；</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package algorithm</span><br><span class="line"></span><br><span class="line">type TreeNode struct &#123;</span><br><span class="line">	Val   int</span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func inorderTraversal(root *TreeNode) (res []int) &#123;</span><br><span class="line">	stack := []*TreeNode&#123;&#125;</span><br><span class="line">	for root != nil || len(stack) &gt; 0&#123;</span><br><span class="line">		for root != nil &#123;</span><br><span class="line">		     stack = append(stack,root)</span><br><span class="line">		     root = root.Left</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		root = stack[len(stack) -1]</span><br><span class="line">		stack = stack[:len(stack)-1]</span><br><span class="line">		res = append(res,tmpVal.Val)</span><br><span class="line">		root = root.Right</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/15/Go-%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/15/Go-%E8%BF%9B%E9%98%B6/" class="post-title-link" itemprop="url">Go 进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-15 23:45:41" itemprop="dateCreated datePublished" datetime="2024-07-15T23:45:41+08:00">2024-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-02 12:11:10" itemprop="dateModified" datetime="2024-08-02T12:11:10+08:00">2024-08-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go-进阶"><a href="#Go-进阶" class="headerlink" title="Go 进阶"></a>Go 进阶</h1><h2 id="Go-GC"><a href="#Go-GC" class="headerlink" title="Go GC"></a>Go GC</h2><p><strong>内存管理的组件</strong></p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/mutator-allocator-collector.png" alt="mutator-allocator-collector"></p>
<p>上图中用户程序（Mutator）通过内存分配器（Allocator）在堆（heap）上分配空间，Go 的垃圾回收器（Collector）回收堆上的空间；</p>
<p>触发GC的条件：</p>
<ul>
<li>阈值：默认内存扩大一倍时，主动触发GC；</li>
<li>定期：默认2min触发一次gc</li>
<li>手动：runtime.gc</li>
</ul>
<h2 id="三色标记-垃圾回收"><a href="#三色标记-垃圾回收" class="headerlink" title="三色标记-垃圾回收"></a>三色标记-垃圾回收</h2><p>三色标记垃圾收集器的执行过程如下：</p>
<ul>
<li>扫描所有存在外部引用的对象，将其标记成灰色；</li>
<li>将集合中标记成黑色</li>
<li>将黑色对象指向的对象标记成灰色</li>
<li>重复上面两个步骤；</li>
</ul>
<p>Go GC的流程：</p>
<p>1、stack scan；收集root对象（全局变量，G stack），<strong>开启写屏障</strong>，开启写屏障需要 <strong>STW</strong>，因此此处进行了一次STW；</p>
<p>2、Mark； 标记所有根对象以及根对象的可达对象；</p>
<p>3、Mark termination；重新扫描全局变量，和上一轮改变的stack（写屏障标记的对象），完成标记工作；此处需要进行一次STW，禁用写屏障；</p>
<p>4、Sweep；按照标记进行垃圾回收；</p>
<p>go 1.8以后 第一次stw也被优化了，只有最后一次stw </p>
<h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>stop the wrold 是整个gc性能最大的问题；</p>
<h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>该屏障提出时的基本思想是：对正在被覆盖的对象进行着色，且如果当前栈未扫描完成， 则同样对指针进行着色。</p>
<h2 id="Go-GMP"><a href="#Go-GMP" class="headerlink" title="Go GMP"></a>Go GMP</h2><p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/GMP%E6%A8%A1%E5%9E%8B.png" alt="GMP模型"></p>
<p>G-M-P分别代表：</p>
<ul>
<li>G - Goroutine，Go协程，是参与调度与执行的最小单位</li>
<li>M - Machine，指的是系统级线程</li>
<li>P - Processor，指的是逻辑处理器，P关联了的本地可运行G的队列(也称为LRQ)，最多可存放256个G</li>
</ul>
<p>GMP调度流程大致如下：</p>
<ul>
<li>线程M想运行任务就需得获取 P，即与P关联。</li>
<li>然后从 P 的本地队列(LRQ)获取 G</li>
<li>若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列，</li>
<li>若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列。</li>
<li>拿到可运行的G之后，M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li>
</ul>
<h2 id="Go内存分配"><a href="#Go内存分配" class="headerlink" title="Go内存分配"></a>Go内存分配</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>Go在程序启动的时候会首先申请一块内存区（虚拟的地址空间），切成小块之后进行管理；分别是spans，bitmap, arena(堆空间)</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/go_mem_base.jpeg" alt="go_mem_base"></p>
<p><code>arena区域</code>就是我们所谓的堆区，Go动态分配的内存都是在这个区域</p>
<p><code>bitmap区域</code>标识<code>arena</code>区域哪些地址保存了对象，并且用<code>4bit</code>标志位表示对象是否包含指针、<code>GC</code>标记信息</p>
<p><code>spans区域</code>存放<code>mspan</code>（也就是一些<code>arena</code>分割的页组合起来的内存管理基本单元，后文会再讲）的指针</p>
<h3 id="内存管理组件"><a href="#内存管理组件" class="headerlink" title="内存管理组件"></a>内存管理组件</h3><h4 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h4><p>​	每一个工作线程都会绑定一个mcache，本地缓存可用的mspan资源，这样可以直接给goroutine用，因为本地缓存的都是不同的mspan因此不同goroutine之间不存在竞争问题，所以不需要消耗锁资源；</p>
<h3 id="内存分配的基本原理"><a href="#内存分配的基本原理" class="headerlink" title="内存分配的基本原理"></a>内存分配的基本原理</h3><p>在计算机科学中，内存分配是指为程序中的变量和数据结构分配存储空间的过程。在 Golang 中，内存分配主要由 Go 运行时系统（runtime）负责，主要包括以下两个方面：</p>
<ul>
<li>堆内存分配：堆内存是用于动态分配的内存区域，主要用于存储程序运行过程中创建的对象和数据结构。通过 new、make 等函数或者使用指针进行内存分配时，都会在堆上分配内存。</li>
<li>栈内存分配：栈内存是用于存放函数调用时的局部变量和返回地址等信息的内存区域。基本类型（如整型、浮点型、布尔型等）和小对象（通常小于 64 字节）的内存分配通常发生在栈上。</li>
</ul>
<p>Go 使用了一个称为“tcmalloc”（thread-caching malloc）的内存分配器，最初由 Google 开发。tcmalloc 的设计目标是减少全局锁的竞争，提高多线程程序的性能。Go 的内存分配器是基于 tcmalloc 概念的一个实现，有几个关键的组成部分：</p>
<ul>
<li>M: 代表操作系统线程（machine）。</li>
<li>P: 代表处理器（processor），管理着一组本地缓存。</li>
<li>G: 代表 goroutine，是 Go 程序执行的最小单位。</li>
</ul>
<p>每个 P 都有自己的内存缓存（mcache），用于小对象的快速分配。当 mcache 用完时，P 会从中心缓存（mcentral）获取内存。如果 mcentral 也不足，内存分配器会向操作系统请求更多内存。</p>
<h2 id="CSP模型"><a href="#CSP模型" class="headerlink" title="CSP模型"></a>CSP模型</h2><p>介绍：CSP用于描述两个独立的并发实体之间通过共享的channel进行通信的并发模型；</p>
<h3 id="CSP模型核心概念"><a href="#CSP模型核心概念" class="headerlink" title="CSP模型核心概念"></a>CSP模型核心概念</h3><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p>Goroutine是Go轻量级线程的实现，启动成本极低，使得并发成为Go程序设计的自然组成部分。通过在函数调用前添加<code>go</code>关键字，即可轻松创建一个新的goroutine。</p>
<h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p>Channel是CSP模型中的核心组件，它提供了一种安全的通信机制，使得goroutines之间能够通过发送和接收数据进行通信。Channel可以是带缓冲或无缓冲的，定义时通过<code>make(chan Type, [buffer])</code>指定。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Received:&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> producer(ch, &amp;wg)</span><br><span class="line"></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> consumer(ch, &amp;wg)</span><br><span class="line"></span><br><span class="line">	wg.Wait() <span class="comment">// 确保所有goroutine完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="常见问题与避免方法"><a href="#常见问题与避免方法" class="headerlink" title="常见问题与避免方法"></a>常见问题与避免方法</h3><h4 id="问题一：数据竞争"><a href="#问题一：数据竞争" class="headerlink" title="问题一：数据竞争"></a>问题一：数据竞争</h4><p>尽管Go的channel设计减少了共享内存的使用，但不当的channel操作仍可能导致数据竞争，尤其是在多goroutine读写同一数据结构时。</p>
<p><strong>避免方法</strong>：确保数据流经channel，避免直接访问共享内存。使用无缓冲channel可以进一步确保数据的顺序处理，减少竞态条件。</p>
<h4 id="问题二：死锁"><a href="#问题二：死锁" class="headerlink" title="问题二：死锁"></a>问题二：死锁</h4><p>死锁通常发生在goroutine互相等待对方释放资源时，如两个goroutine互相发送数据但没有接收。</p>
<p><strong>避免方法</strong>：使用<code>select</code>语句处理channel操作，它可以监听多个channel，并提供默认分支处理无人发送或接收的情况。</p>
<h4 id="问题三：goroutine泄漏"><a href="#问题三：goroutine泄漏" class="headerlink" title="问题三：goroutine泄漏"></a>问题三：goroutine泄漏</h4><p>未正确关闭或管理goroutine可能导致它们永远运行，占用资源。</p>
<p><strong>避免方法</strong>：使用<code>sync.WaitGroup</code>或channel来同步goroutine的结束，确保所有goroutine完成后再退出主程序。</p>
<h2 id="chan-原理"><a href="#chan-原理" class="headerlink" title="chan 原理"></a>chan 原理</h2><h3 id="Chan数据结构"><a href="#Chan数据结构" class="headerlink" title="Chan数据结构"></a>Chan数据结构</h3><p>​	chan 通道的数据结构如下，重点关注为：</p>
<ul>
<li>buf：有缓存区chan的循环列表；保障空间不会被浪费；</li>
<li>elemtype：chan对象的类型</li>
<li>sendx：发送元素索引</li>
<li>recvx：接收元素索引</li>
<li>recvq：接收 goroutine 队列</li>
<li>sendq: 发送 goroutine 队列</li>
</ul>
<p>![chan 数据结构](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/chan">https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/chan</a> 数据结构.png)</p>
<p>channel 中用到了两个数据结构：<strong>循环队列</strong> 和 <strong>双端链表</strong>；</p>
<p><strong>循环队列</strong> 只有在有缓冲 channel 中才会使用，它主要是做为消息的缓冲、保证消息的有序性；</p>
<p><strong>双端链表</strong> 是用来挂起阻塞的读、写 goroutine 的，在被唤醒时会按照入队顺序公平的进行通知；</p>
<p>无缓冲的 channel 不会用到 <strong>循环队列</strong> 相关的结构，它必须读写 goroutine 都准备好后才能进行消息交换；</p>
<p>做为缓冲消息的 <strong>循环队列</strong> 通过一个当前元素个数字段的标记，避免了浪费一个数据空间</p>
<h4 id="chan的内存泄漏问题"><a href="#chan的内存泄漏问题" class="headerlink" title="chan的内存泄漏问题"></a>chan的内存泄漏问题</h4><p>泄漏的原因是 goroutine 操作 channel 后，处于<strong>发送或接收阻塞状态</strong>，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。</p>
<ul>
<li>使用超时控制；</li>
<li>新增关闭channel</li>
</ul>
<h3 id="chan-使用规范"><a href="#chan-使用规范" class="headerlink" title="chan 使用规范"></a>chan 使用规范</h3><p>什么场景不能使用：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>channel状态</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>reade</td>
<td>只写</td>
<td>编译失败</td>
</tr>
<tr>
<td>write</td>
<td>关闭</td>
<td>panic</td>
</tr>
<tr>
<td>write</td>
<td>只读</td>
<td>编译失败</td>
</tr>
<tr>
<td>close</td>
<td>nil</td>
<td>panic</td>
</tr>
<tr>
<td>close</td>
<td>关闭</td>
<td>painc</td>
</tr>
</tbody></table>
<h2 id="context-结构原理"><a href="#context-结构原理" class="headerlink" title="context 结构原理"></a>context 结构原理</h2><p><code>context</code>主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。另外在使用<code>context</code>时有两点值得注意：上游任务仅仅使用<code>context</code>通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说<code>context</code>的取消操作是无侵入的；<code>context</code>是线程安全的，因为<code>context</code>本身是不可变的（<code>immutable</code>），因此可以放心地在多个协程中传递使用。</p>
<h3 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h3><ul>
<li><code>Done</code> : 返回一个只读chan；当这个chan关闭时说明context被取消了； 此 chan 没有任何地方往里塞东西；</li>
<li><code>Err</code> : 返回channel被关闭的原因；</li>
<li><code>Deadline</code> : 返回context的截止时间；</li>
<li><code>Value</code> :  返回之前设置的key对应的value</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 当 context 被取消或者到了 deadline，返回一个被关闭的 channel</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在 channel Done 关闭后，返回 context 取消原因</span></span><br><span class="line">	Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 context 是否会被取消以及自动取消时间（即 deadline）</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 key 对应的 value</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="canceler接口"><a href="#canceler接口" class="headerlink" title="canceler接口"></a>canceler接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">	cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Context-实现"><a href="#Context-实现" class="headerlink" title="Context 实现"></a>Context 实现</h3><p>Context包中以下四种类型实现了Context接口：<code>EmptyContext</code>, <code>valueCtx</code>, <code>cancelCtx</code>,  <code>timerCtx</code> ;</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/Context%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="Context继承关系"></p>
<h4 id="EmptyCtx"><a href="#EmptyCtx" class="headerlink" title="EmptyCtx"></a>EmptyCtx</h4><ul>
<li>内部实现全部返回nil，因此是一个空的Context；</li>
<li>通过context.Background() 获取；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="cancelCtx"><a href="#cancelCtx" class="headerlink" title="cancelCtx"></a>cancelCtx</h4><p>1、cancelCtx结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保护之后的字段</span></span><br><span class="line">	mu       sync.Mutex</span><br><span class="line">	done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	err      <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、cancelCtx的 Done 实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d := c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过上面方法能看出来 Context 的 Done 函数是一个线程安全的函数，当触发取消消息时，进行加锁，防止多线程并发问题；</li>
<li>c.done 的创建可以看出 c.done 是一个懒汉式的创建，只有在需要的时候才会常见 chan ；</li>
</ul>
<p>3、cancelCtx的 cancel 实现</p>
<p>源码：大体上来说：cancelCtx 的主要功能就是关闭Channel，并且递归的取消他的所有子节点；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 必须要传 err</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// 已经被其他协程取消</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 给 err 字段赋值</span></span><br><span class="line">	c.err = err</span><br><span class="line">	<span class="comment">// 关闭 channel，通知其他协程</span></span><br><span class="line">	<span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.done = closedchan</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历它的所有子节点</span></span><br><span class="line">	<span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">	    <span class="comment">// 递归地取消所有子节点</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将子节点置空</span></span><br><span class="line">	c.children = <span class="literal">nil</span></span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">	    <span class="comment">// 从父节点中移除自己 </span></span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ValueContext"><a href="#ValueContext" class="headerlink" title="ValueContext"></a>ValueContext</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">	<span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">		<span class="keyword">return</span> c.val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该ValueContext自己实现了Value方法以及string方法；</p>
<h3 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h3><h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel()"></a>WithCancel()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	c := newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	<span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	调用withCancel需要用到一个父节点，返回一个子节点，和一个<strong>取消子节点的函数</strong>；</p>
<ul>
<li>newCancelCtx: 函数返回一个带有父节点的可取消Context；</li>
</ul>
<h4 id="propagateCancel-分析"><a href="#propagateCancel-分析" class="headerlink" title="propagateCancel 分析"></a>propagateCancel 分析</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">	done := parent.Done()</span><br><span class="line">	<span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">		<span class="comment">// parent is already canceled</span></span><br><span class="line">		child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// parent has already been canceled</span></span><br><span class="line">			child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">				p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">				child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">			<span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/context%E5%AD%90%E8%8A%82%E7%82%B9%E5%8F%96%E6%B6%88.png" alt="context子节点取消"></p>
<h4 id="value-分析；"><a href="#value-分析；" class="headerlink" title="value() 分析；"></a>value() 分析；</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *valueCtx:</span><br><span class="line">			<span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">				<span class="keyword">return</span> ctx.val</span><br><span class="line">			&#125;</span><br><span class="line">			c = ctx.Context</span><br><span class="line">		<span class="keyword">case</span> *cancelCtx:</span><br><span class="line">			<span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">				<span class="keyword">return</span> c</span><br><span class="line">			&#125;</span><br><span class="line">			c = ctx.Context</span><br><span class="line">		<span class="keyword">case</span> *timerCtx:</span><br><span class="line">			<span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">			&#125;</span><br><span class="line">			c = ctx.Context</span><br><span class="line">		<span class="keyword">case</span> *emptyCtx:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> c.Value(key)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	该方法中若是Value方法则判断key是否与value中的一致，否则从父节点中寻找，直到最找到，若都没有找到则返回该context中的value值；</p>
<p>[官方Context文档翻译篇]: <a target="_blank" rel="noopener" href="https://brantou.github.io/2017/05/19/go-concurrency-patterns-context/">https://brantou.github.io/2017/05/19/go-concurrency-patterns-context/</a>	“ 官方文档”</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="切片与数组的区别"><a href="#切片与数组的区别" class="headerlink" title="切片与数组的区别"></a>切片与数组的区别</h3><p>介绍：slice 的底层数据是数组，slice 是对数组的封装</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>数组</th>
<th>切片</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>数组长度是固定的</td>
<td>切片长度可动态扩容</td>
</tr>
<tr>
<td>2</td>
<td>数组是一片连续的内存</td>
<td>切片是一个结构体：长度、容量、底层数组</td>
</tr>
<tr>
<td>3</td>
<td>不同长度数组是不同类型</td>
<td>而切片只要类型一致就是相同类型</td>
</tr>
</tbody></table>
<p>切片的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/%E5%88%87%E7%89%87%E7%BB%93%E6%9E%84.png" alt="切片结构"></p>
<h3 id="切片的动态扩容"><a href="#切片的动态扩容" class="headerlink" title="切片的动态扩容"></a>切片的动态扩容</h3><p>在golang1.18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的：</p>
<blockquote>
<p>当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍。</p>
</blockquote>
<p>在1.18版本更新之后，slice的扩容策略变为了：</p>
<blockquote>
<p>当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap &#x3D; oldcap+(oldcap+3*256)&#x2F;4</p>
</blockquote>
<p><code>在以上动态扩容之后还会进行内存对齐，有待研究</code></p>
<h3 id="切片非线程安全"><a href="#切片非线程安全" class="headerlink" title="切片非线程安全"></a>切片非线程安全</h3><p>不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。</p>
<ul>
<li>slice的底层数据是一个unsafe.Pointer，也就是指针;</li>
<li>并发读写时数据不一致，可能会被覆盖</li>
<li>动态扩容时，多个 goroutine 进行读写，也会导致数据丢失问题；</li>
</ul>
<h3 id="切片的Append操作"><a href="#切片的Append操作" class="headerlink" title="切片的Append操作"></a>切片的Append操作</h3><ul>
<li>当切片进行appden操作时，若是以为数组则将会拷贝值到添加的数组中，若拷贝的是一个二维数组，则拷贝切片到添加的数组中，此时改变之前的数组会导致添加的数组也随着改变；</li>
</ul>
<p>&#x2F;&#x2F; 示例：append操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums := [][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line">nums2 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">tmp1 := []<span class="type">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">result := <span class="built_in">append</span>(nums, tmp1)</span><br><span class="line">result2 := <span class="built_in">append</span>(nums2, tmp1...)</span><br><span class="line"></span><br><span class="line">tmp1[<span class="number">1</span>] = <span class="number">9</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">fmt.Println(result2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">[[1 2 3] [3 9]]</span><br><span class="line">[1 2 3 3 4]</span><br></pre></td></tr></table></figure>



<p>Append 执行过程，<strong>工作原理</strong>：</p>
<p>当使用<code>append</code>函数向切片添加元素时，Go语言会首先检查切片的容量是否足够。如果容量不足，<code>append</code>函数会执行扩容操作。扩容操作的过程如下：</p>
<ol>
<li><strong>计算新长度</strong>：首先，<code>append</code>函数会计算出新切片的长度，即原始切片长度加上要添加的元素个数。</li>
<li><strong>分配新内存</strong>：然后，<code>append</code>函数会在堆上分配足够大的内存空间来容纳新切片。这个内存空间的大小通常是原始切片的两倍，以确保足够的容量。</li>
<li><strong>拷贝数据</strong>：接下来，<code>append</code>函数会将原始切片中的数据拷贝到新分配的内存空间中。</li>
<li><strong>添加新元素</strong>：最后，<code>append</code>函数会将新元素添加到新分配的内存空间的末尾。</li>
<li><strong>返回新切片</strong>：完成上述操作后，<code>append</code>函数返回新的切片，该切片指向新分配的内存空间。</li>
</ol>
<p>什么时候Append会失败：</p>
<ul>
<li>重新分配内存时，无内存可用；</li>
</ul>
<h2 id="Map数据结构，并发安全"><a href="#Map数据结构，并发安全" class="headerlink" title="Map数据结构，并发安全"></a>Map数据结构，并发安全</h2><h3 id="Map的内部源码"><a href="#Map的内部源码" class="headerlink" title="Map的内部源码"></a>Map的内部源码</h3><ul>
<li>在Go中map是一个指针，指向的是<code>hmap</code>的结构体</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">	count     <span class="type">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>        </span><br><span class="line">    <span class="comment">// len为8的数组</span></span><br><span class="line">    <span class="comment">// 用来快速定位key是否在这个bmap中</span></span><br><span class="line">    <span class="comment">// 桶的槽位数组，一个桶最多8个槽位，如果key所在的槽位在tophash中，则代表该key在这个桶中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//底层定义的常量 </span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    bucketCntBits = <span class="number">3</span></span><br><span class="line">    bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits</span><br><span class="line">    <span class="comment">// 一个桶最多8个位置</span></span><br><span class="line">）</span><br><span class="line"></span><br><span class="line">但这只是表面(src/runtime/hashmap.<span class="keyword">go</span>)的结构，编译期间会给它加料，动态地创建一个新的结构：</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    </span><br><span class="line">  tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">    </span><br><span class="line">  topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">  keys     [<span class="number">8</span>]keytype</span><br><span class="line">  values   [<span class="number">8</span>]valuetype</span><br><span class="line">  pad      <span class="type">uintptr</span></span><br><span class="line">  overflow <span class="type">uintptr</span></span><br><span class="line">  <span class="comment">// 溢出桶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Map的rehash"><a href="#Map的rehash" class="headerlink" title="Map的rehash"></a>Map的rehash</h3><h4 id="hash冲突解决方案"><a href="#hash冲突解决方案" class="headerlink" title="hash冲突解决方案"></a>hash冲突解决方案</h4><p>开放寻址法</p>
<p>拉链法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/14/C++%E6%8C%87%E9%92%88%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/14/C++%E6%8C%87%E9%92%88%E7%AF%87/" class="post-title-link" itemprop="url">C++指针篇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-14 18:36:58" itemprop="dateCreated datePublished" datetime="2024-04-14T18:36:58+08:00">2024-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-16 23:59:42" itemprop="dateModified" datetime="2024-07-16T23:59:42+08:00">2024-07-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-指针篇"><a href="#C-指针篇" class="headerlink" title="C++指针篇"></a>C++指针篇</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>本篇基于一定的C++基础进行讲解，基础知识一带而过；</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul>
<li>指针存储在哪？<ul>
<li>我们通过new进行结构的初始化，此时会在自由存储空间（堆空间）进行内存分配；</li>
</ul>
</li>
<li>指针存储的值是什么？<ul>
<li>指针本身代表的是内存地址，内存地址上的值则是我们声明的变量；</li>
</ul>
</li>
<li>指针的信息是什么类型？<ul>
<li>指针的类型在C++中我们将其看作是十六进制的int类型（强调：只是看作）</li>
</ul>
</li>
</ul>
<h3 id="指针声明-amp-初始化"><a href="#指针声明-amp-初始化" class="headerlink" title="指针声明&amp;初始化"></a>指针声明&amp;初始化</h3><ul>
<li>demo</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">People</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> age):<span class="built_in">name</span>(name),<span class="built_in">age</span>(age)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = &amp;name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ptr1 为指针类型，ptr2为int类型</span></span><br><span class="line">    <span class="type">int</span> *ptr1, ptr2;</span><br><span class="line">    </span><br><span class="line">    People p = <span class="keyword">new</span> <span class="built_in">People</span>(<span class="string">&quot;Rock&quot;</span>,<span class="number">25</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 裸指针必须释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明&amp;初始化</li>
</ul>
<p><code>int * ptr</code></p>
<p>*注意：在我们声明指针时一定要对指针初始化，否则后续对指针的赋值可能是非预期的结果；</p>
<p><code>int * ptr = new int</code></p>
<h3 id="数组的静态联编和动态联编"><a href="#数组的静态联编和动态联编" class="headerlink" title="数组的静态联编和动态联编"></a>数组的静态联编和动态联编</h3><p>静态联编，顾名思义为程序静态编译时的行为；</p>
<p>int number[10] ;</p>
<p>动态联编, 程序动态运行时进行的操作；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; size;</span><br><span class="line"><span class="type">int</span> * ptr = <span class="keyword">new</span> <span class="type">int</span>[size] ;</span><br><span class="line"><span class="comment">// 等价于*ptr = 1;</span></span><br><span class="line">ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">*(ptr + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>



<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><ul>
<li>自动存储，静态存储，动态存储；</li>
</ul>
<p>自动存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    int number = 1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码闭包中的零时变量都是自动存储类型，当函数或闭包结束时零时变量将依次释放；</p>
<p>静态存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> number;</span><br></pre></td></tr></table></figure>

<p>静态存储为全局变量，当使用static活着在函数外部定义时定义，静态变量将贯穿整个程序的生命周期；</p>
<p>动态存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * ptr = <span class="keyword">new</span> <span class="type">int</span> </span><br></pre></td></tr></table></figure>

<p>动态变量使用new进行初始化的变量，创建在堆区（自由存储区），动态存储变量需要使用delete进行删除，他不会随着函数或闭包的结束而释放；因此当出现使用new进行初始化的变量时，应该使用delete进行内存释放，否则会出现内存泄漏问题；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/26/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/26/Mysql/" class="post-title-link" itemprop="url">Mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-26 22:24:54" itemprop="dateCreated datePublished" datetime="2023-12-26T22:24:54+08:00">2023-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-29 10:35:59" itemprop="dateModified" datetime="2024-07-29T10:35:59+08:00">2024-07-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mysql-基础"><a href="#Mysql-基础" class="headerlink" title="Mysql 基础"></a>Mysql 基础</h1><h2 id="MYSQL四大特性"><a href="#MYSQL四大特性" class="headerlink" title="MYSQL四大特性"></a>MYSQL四大特性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li>事务是最小执行单位，不允许有分割，要么全部执行，要么都不做；</li>
</ul>
<h4 id="实现原理：undo-log"><a href="#实现原理：undo-log" class="headerlink" title="实现原理：undo log"></a>实现原理：undo log</h4><p>在说明原子性原理之前，首先介绍一下MySQL的事务日志。MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。</p>
<p>下面说回undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。<strong>InnoDB</strong>实现回滚，靠的是<strong>undo log</strong>：当事务对数据库进行修改时，InnoDB<strong>会生成对应的undo log</strong>；如果事务执行失败或调用了rollback<strong>，导致事务需要回滚，便可以利用undo log</strong>中的信息将数据回滚到修改之前的样子。</p>
<p>undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p>
<p>以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><ul>
<li>事务一旦提交，对数据库的改变就是永久的；</li>
</ul>
<h4 id="实现原理：redo-log"><a href="#实现原理：redo-log" class="headerlink" title="实现原理：redo log"></a>实现原理：redo log</h4><p>当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p>
<p>既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：</p>
<p>（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</p>
<p>（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><ul>
<li>并发执行时事务之间互不影响</li>
</ul>
<h4 id="实现原理：锁机制"><a href="#实现原理：锁机制" class="headerlink" title="实现原理：锁机制"></a>实现原理：锁机制</h4><p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。</p>
<p>锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p>
<p><strong>行锁与表锁</strong></p>
<p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/mysql_%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="mysql_隔离级别"></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><ul>
<li>一致性是指事务执行结束后，<strong>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</strong>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。</li>
<li>前面三个都是为了保证一致性</li>
</ul>
<h2 id="Mysql架构"><a href="#Mysql架构" class="headerlink" title="Mysql架构"></a>Mysql架构</h2><p>Mysql主要分为三层，客户层，server层，存储引擎层（存储引擎层提供接口用于数据读写接口）</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/MySql_arch.png" alt="image-20240630231048538"></p>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><ul>
<li>一种能帮助mysql提高了查询效率的数据结构：<strong>索引数据结构</strong>。</li>
</ul>
<h3 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h3><p>索引的存储原理大致可以概括为一句话：<strong>以空间换时间</strong>。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此<code>索引往往是存储在磁盘上的文件中的</code>（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</p>
<p>数据库在未添加索引进行查询的时候默认是进行全文搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕。</p>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul>
<li><p>主键索引：primary key </p>
<ul>
<li>设定主键后，数据库自动建立的索引，innoDb引擎为聚簇索引；</li>
</ul>
</li>
<li><p>普通索引</p>
<ul>
<li>mysql中的基础索引类型，没有什么限制，允许在索引列插入NULL</li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li>索引列的值必须唯一</li>
</ul>
</li>
<li><p>复合索引</p>
<ul>
<li>一个索引可以包含多个列，多个列共同构成一个复合索引</li>
</ul>
</li>
<li><p>前缀索引</p>
<ul>
<li>使用BLOG，TEXT，长类型varchar类型时可以使用前缀索引；</li>
</ul>
</li>
<li><p>全文索引</p>
<ul>
<li>char，varchar上的全文查找</li>
</ul>
</li>
<li><p>空间索引</p>
</li>
</ul>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>Mysql索引有两大数据结构：</p>
<ul>
<li>B+ Tree </li>
<li>hash</li>
</ul>
<p>对于大部分单条查询hash索引即可满足查询性能，其余的建议使用B+树</p>
<p>B+树的演变：</p>
<ul>
<li><p>二叉树</p>
<ul>
<li>当二叉树插入的数据都是大于前一个数据时会成为一链表结构，即为线性树；</li>
</ul>
</li>
<li><p>平衡二叉树</p>
<ul>
<li>每次插入时会判断<strong>每个节点的左子树和右子树的高度差不能超过 1</strong></li>
<li>但是当插入元素过多时会出现树的高度过大的问题；</li>
</ul>
</li>
<li><p>B树</p>
<ul>
<li>允许一个节点可以有两个以上的子叶子节点；</li>
<li>但是做范围查询时需要使用中序遍历，设计多个节点的磁盘I&#x2F;O</li>
</ul>
</li>
<li><p>B+树</p>
<ul>
<li>最底部存放的不再只是索引，而是存储索引+数据</li>
<li>最底部的叶子节点之间形成有序链表</li>
</ul>
</li>
</ul>
<h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>hash表介绍</p>
<p>  我们使用hash表存储表数据结构，<strong>Key可以存储索引列，Value可以存储行记录或者行磁盘地址</strong>。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时只能通过扫描全表的方式，筛选出符合条件的数据。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p><code> 聚簇索引不是一种索引类型，而是一种数据存储方式</code></p>
<p><strong>介绍</strong>:</p>
<ul>
<li><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p>
</li>
<li><p>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</p>
</li>
</ul>
<p><strong>澄清一个概念</strong>：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</p>
<ul>
<li>聚簇索引：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B.png" alt="image-20240630232608169"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将<strong>主键组织到一棵B+树</strong>中，而<strong>行数据就储存在叶子节点</strong>上，若使用”where id &#x3D; 14”这样的条件查找主键，则<strong>按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据</strong>。</li>
<li>若<strong>对Name列进行条件搜索，则需要两个步骤</strong>：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</strong>。第二步<strong>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</strong>。（<strong>重点在于通过其他键需要建立辅助索引</strong>）</li>
</ol>
<p><strong>聚簇索引的误区</strong></p>
<ul>
<li><strong>把主键自动设为聚簇索引</strong>： 聚簇索引具有唯一性，且性能最好；因此设置聚簇索引时我们必须谨慎设置；</li>
<li><strong>聚簇索引需要两次B+树查找效率看起来”更低”：</strong><ul>
<li>首先明确聚簇索引的使用场景：插入较少（当使用uuid作为主键时会导致数据插入到之前记录的中间，需要强制移动之前的记录，因此大量新行插入不适用），建议使用自增id作用主键（前面场景说到聚簇索引需要谨慎，实际上生活中也存在顺序主键比如：学号，班级等），这时主键页会按照顺序填满；</li>
<li>适合使用在排序的场景，因为相邻数据放在一起（同一页中），I&#x2F;O次数更少</li>
</ul>
</li>
</ul>
<p><strong>聚簇索引也有缺点</strong></p>
<ul>
<li>维护索引开销大：<strong>特别是插入新行或者主键被更新导至要分页(page split)的时候</strong>；</li>
<li>表因为使用UUId（随机ID）作为主键，使数据存储稀疏；</li>
</ul>
<h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ol>
<li><p><strong>最左前缀匹配原则</strong>，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
</li>
<li><p><strong>&#x3D;和in可以乱序</strong>，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
</li>
<li><p><strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p>
</li>
<li><p><strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’)。</p>
</li>
<li><p><strong>尽量的扩展索引</strong>，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
</li>
</ol>
<h1 id="MySQL-问题调优"><a href="#MySQL-问题调优" class="headerlink" title="MySQL 问题调优"></a>MySQL 问题调优</h1><h2 id="MySQL深度翻页"><a href="#MySQL深度翻页" class="headerlink" title="MySQL深度翻页"></a>MySQL深度翻页</h2><h2 id="SQL卡死"><a href="#SQL卡死" class="headerlink" title="SQL卡死"></a>SQL卡死</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><pre><code>客户私有化环境中执行sql文件时卡死，从现象上看是卡死在某一个语句，单独拿出来依然无法执行；从私有化环境中导出到开发环境执行，成功通过；初步怀疑是环境问题，从docker环境中新建一个相同的镜像环境，执行依然成功；问题卡住；
我们从头开始分析：
1、执行explain未发现问题
2、执行show full proceelist 发现没有连接；
此时还没发现问题，以为是卡在了语法解析阶段（因为sql特别大有7、8M）；
后重新使用docker环境执行show full processlist 发现docker 上居然有！此时怀疑客户私有化环境上没连上server端，怀疑代理问题；让客户直连mysql，执行成功！！
以上问题主要是对mysql的执行过程不太熟练导致，因此一下补充mysql执行过程已经mysql架构等知识；
</code></pre>
<h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><p>mysql架构分为以下三层</p>
<ul>
<li>客户端服务层：客户端服务层主要完成鉴权，链接处理，授权认证；</li>
<li>核心服务层： 核心服务层包含链接线程池，查询解析，分析，优化，缓存，内置函数等；一切mysql的处理都在核心服务层；</li>
<li>存储引擎层：负责mysql的存储以及提取；</li>
</ul>
<h3 id="sql语句执行分析"><a href="#sql语句执行分析" class="headerlink" title="sql语句执行分析"></a>sql语句执行分析</h3><ul>
<li><p>万能的Explain（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html%EF%BC%89">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html）</a></p>
<ul>
<li>explain select * from table where Id&#x3D;1；</li>
<li>explain 展示字段：</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>    <span class="operator">|</span> Extra       <span class="operator">|</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>processlist mysql server端中的连接；</p>
<ul>
<li>show full processlist</li>
</ul>
</li>
</ul>
<h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h3 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h3><h2 id="Mysql基础函数"><a href="#Mysql基础函数" class="headerlink" title="Mysql基础函数"></a>Mysql基础函数</h2><ul>
<li><code>mysql</code> 中的各种调用函数，常用的时间转换函数</li>
</ul>
<h2 id="str-to-date-时间转换函数"><a href="#str-to-date-时间转换函数" class="headerlink" title="str_to_date 时间转换函数"></a><code>str_to_date</code> 时间转换函数</h2><p>在<code>mysql</code>中<code>str_to_date</code>函数是一个非常有用的函数，能够将字符串转换为日期格式；</p>
<ul>
<li><code>str_to_date(&#39;str&#39;,&#39;model&#39;)</code>;其中<code>model</code>是转换的格式<code>%Y-%m-%d %H:%i:%s</code>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 示例：</span><br><span class="line">update saas_smart_list_content set startTime = STR_TO_DATE(&#x27;2022-04-01 17:46:38&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;) where startTime = STR_TO_DATE(&#x27;0000-00-00 00:00:00&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;) limit 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from saas_smart_list_content where startTime &lt;= STR_TO_DATE(&#x27;2022-04-01 17:46:38&#x27;, &#x27;%Y-%m-%d %H:%i:%s&#x27;) limit 1;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/Redis/" class="post-title-link" itemprop="url">Redis进阶</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 22:37:36" itemprop="dateCreated datePublished" datetime="2023-08-22T22:37:36+08:00">2023-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-20 12:17:54" itemprop="dateModified" datetime="2024-07-20T12:17:54+08:00">2024-07-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>key 命令：</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>del key</td>
<td>删除指定的key， 可以同时删除多个：del key1 key2 …</td>
</tr>
<tr>
<td align="center">2</td>
<td>dump key</td>
<td>序列号给定key</td>
</tr>
<tr>
<td align="center">3</td>
<td>exist key</td>
<td>检查key是否存在</td>
</tr>
<tr>
<td align="center">4</td>
<td>expire key second</td>
<td>给key设置过期时间</td>
</tr>
<tr>
<td align="center">5</td>
<td>key pattern</td>
<td>查找所有符合（pattern）的key； （*代表多个，？代表一个）</td>
</tr>
<tr>
<td align="center">6</td>
<td>persist key</td>
<td>移除key的过期时间</td>
</tr>
<tr>
<td align="center">7</td>
<td>ttl key</td>
<td>返回key的剩余生存时间</td>
</tr>
<tr>
<td align="center">8</td>
<td>type key</td>
<td>返回key的类型</td>
</tr>
<tr>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>String 命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SET</td>
<td align="left">设置指定 key 的值</td>
</tr>
<tr>
<td align="left">GET</td>
<td align="left">获取指定 key 的值</td>
</tr>
<tr>
<td align="left">getrange</td>
<td align="left">返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td align="left">getset</td>
<td align="left">将给定 key 的值设为 value ，并返回 key 的旧值 ( old value )</td>
</tr>
<tr>
<td align="left">mget</td>
<td align="left">获取所有(一个或多个)给定 key 的值</td>
</tr>
<tr>
<td align="left">setex</td>
<td align="left">设置 key 的值为 value 同时将过期时间设为 seconds</td>
</tr>
<tr>
<td align="left">setnx</td>
<td align="left">只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td align="left">mset</td>
<td align="left">同时设置一个或多个 key-value 对</td>
</tr>
<tr>
<td align="left">incr</td>
<td align="left">将 key 中储存的数字值增一</td>
</tr>
<tr>
<td align="left">append</td>
<td align="left">将 value 追加到 key 原来的值的末尾</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>Hash 命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HDEL key field1 [field2]</td>
<td align="left">删除一个或多个hash字段</td>
</tr>
<tr>
<td align="left">Hget key field</td>
<td align="left">获取哈希表中指定字段的值</td>
</tr>
<tr>
<td align="left">Hkeys key</td>
<td align="left">获取哈希表中所有字段</td>
</tr>
<tr>
<td align="left">HValue</td>
<td align="left">获取哈希表中所有值</td>
</tr>
<tr>
<td align="left">Hset key filed value</td>
<td align="left">将哈希表key中的字段field设置为value</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>更多资料查看：<a target="_blank" rel="noopener" href="https://redis.com.cn/commands.html">https://redis.com.cn/commands.html</a></p>
<h2 id="Redis中不同的类型的数据结构"><a href="#Redis中不同的类型的数据结构" class="headerlink" title="Redis中不同的类型的数据结构"></a>Redis中不同的类型的数据结构</h2><ul>
<li>介绍：redis中有以下五种数据结构<ul>
<li>string ， list， hash，set， zset（有序集合列表）</li>
</ul>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul>
<li>介绍：string类型的底层数据结构实现主要是int，sds（简单动态字符串），与常规C字符串的区别是：<ul>
<li>SDS不仅可以保存文本数据，还可以保存二进制数据；</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查</li>
</ul>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong></p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_list_%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0.png" alt="redis_list_内部实现"></p>
<p>常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"># 将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"># 移除并返回key列表的头元素</span><br><span class="line">LPOP key     </span><br><span class="line"># 移除并返回key列表的尾元素</span><br><span class="line">RPOP key </span><br><span class="line"></span><br><span class="line"># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span><br><span class="line">LRANGE key start stop</span><br><span class="line"></span><br><span class="line"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>



<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>消息队列在存取消息时，必须要满足两个需求，分别是<strong>消息保序、和保证消息可靠性</strong>。</p>
<p>1、如何满足消息的顺序性；</p>
<p>​    List本身就是按照先进先出的顺序对数据进行存取；因此本身数据结构就支持顺序性；</p>
<p>​	我们在使用List的时候按照：LPUST+RPOP（或者反过来RPUSH+LPOP），即可实现顺序性；</p>
<p>2、若列表中没有数据，消费者会不断的循环加载，消耗CPU性能；此时可以使用<code>BRPOP</code>，当没有内容时会进行阻塞，但是同样当限制时间过长时会<strong>断开连接</strong>；此时需要进行<strong>异常处理重试</strong>；</p>
<p>3、如何保证消息可靠性？</p>
<p>​	 当服务拿到消费数据时出现异常，此时以前的数据将会丢失；为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p>
<p>缺陷：</p>
<ul>
<li>不支持多个消费者消费同一条消息；</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>介绍：Hash 是一个键值对（key - value）集合，其中 value 的形式如： <code>value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</code>。Hash 特别适合用于存储对象。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/hash%E4%B8%8Estring.png" alt="hash与string"></p>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><h5 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h5><p>Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。</p>
<p>我们以用户信息为例，它在关系型数据库中的结构是这样的：</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF.webp" alt="用户信息"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; HMSET uid:1 name Tom age 15</span><br><span class="line">2</span><br><span class="line"># 存储一个哈希表uid:2的键值</span><br><span class="line">&gt; HMSET uid:2 name Jerry age 13</span><br><span class="line">2</span><br><span class="line"># 获取哈希表用户id为1中所有的键值</span><br><span class="line">&gt; HGETALL uid:1</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;15&quot;</span><br></pre></td></tr></table></figure>



<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>介绍：Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<p>redis 运算操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 交集运算</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"># 将交集结果存入新集合destination中</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 并集运算</span><br><span class="line">SUNION key [key ...]</span><br><span class="line"># 将并集结果存入新集合destination中</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 差集运算</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"># 将差集结果存入新集合destination中</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>

<h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>
<p>但是要提醒你一下，这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计；</p>
<h6 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h6><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id</p>
<h6 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h6><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<h6 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h6><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次</p>
<h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>介绍：Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p>
<p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<h5 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h5><ul>
<li>排行榜</li>
<li>电话、姓名排序</li>
</ul>
<h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h4><p>介绍：Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。</p>
<h5 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h5><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p>
<h5 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h5><p>签到统计（只有0&#x2F;1）,判断用户登陆态 , 连续签到用户总数</p>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>介绍：redis 2.8.9 版本新增类型。提供不精确的去重计算，官方提供误差率不超过0.81%</p>
<p>应用场景：百万级别网页UV计数；</p>
<h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><p>介绍：redis GEO 是Redis3.2版本新增的数据类型，主要用于存储地理位置信息；</p>
<p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p>
<p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数；</p>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>介绍：redis 5.0 版本新增的数据类型，Redis专门为消息队列设计的数据类型；</p>
<p>背景：之前<code>list</code>实现的消息队列有以下缺点</p>
<ul>
<li>发布订阅模式，不能持久化无法可靠的保存消息；重连的客户端无法读到历史记录；</li>
<li>List实现消息队列无法进行重复消费，消息消费完之后就会被删除；</li>
</ul>
<p>基于以上问题：</p>
<p>Stream类型</p>
<ul>
<li>支持消息的持久化，支持自动生成全局唯一ID，支持ACK确认的模式，支持消费组模式；</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>介绍：<code>RDB</code>文件内容是二进制数据， 默认开启；RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据；因此在 Redis 恢复数据时，RDB 恢复数据的效率会比 AOF 高些；</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>介绍：<code>AOF（Append Only File）</code>,将redis执行的每条写操作命令都追加到一个文件里；默认不开启；</p>
<p><strong>AOF先执行写操作命令</strong>，执行成功之后才会进行持久化保存, 这样做有以下几个优势：</p>
<ul>
<li>避免额外的语法检查开销</li>
<li>不会阻塞当前写操作命令的执行；但会给下一条命令带来阻塞风险；</li>
</ul>
<p>因为将命令写入到日志的这个操作也是在主进程完成的（执行命令也是在主进程），也就是说这两个操作是同步的。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_aof%E6%93%8D%E4%BD%9C.png" alt="redis_aof操作"></p>
<p>如果服务器磁盘I&#x2F;O压力过大，会导致写入速度很慢，从而导致阻塞下条命令执行；</p>
<h4 id="三种写策略"><a href="#三种写策略" class="headerlink" title="三种写策略"></a>三种写策略</h4><p>Redis 写入 AOF 日志的过程，如下图：</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_AOF%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="redis_AOF的写操作流程"></p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 <strong>3 种写回硬盘的策略</strong>，控制的就是上面说的第三步的过程。</p>
<p>在redis.conf配置文件中 <code>appendfsync</code>配置项有三个可选参数：</p>
<ul>
<li>always，每次执行写操作命令，同步将AOF日志数据写回硬盘；</li>
<li>Everysec， 先将命令写入到AOF文件的内核缓冲区，每隔一秒将缓冲区的内容写入到硬盘；</li>
<li>NO， 由操作系统控制写入磁盘的时机，该参数性能较好；</li>
</ul>
<p>以上三个配置项的使用场景：</p>
<ul>
<li><p>Always 策略的话，可以<strong>最大程度保证数据不丢失</strong>，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；</p>
</li>
<li><p>No 策略的话，是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always <strong>策略性能较好</strong>，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。</p>
</li>
<li><p>Everysec 策略的话，是<strong>折中的一种方式</strong>，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/appendfsync%E7%9A%84%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AE.png"></p>
</li>
</ul>
<h5 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h5><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。</p>
<p>所以Redis提供 <code>AOF</code>重写机制，当AOF文件大小超过指定阈值时，Redis就会启用AOF重写机制，来压缩AOF文件；</p>
<p>AOF重写机制就是在重写时，读取当前数据库中的所有键值对，然后每一个键值对用一个命令记录到 <strong>新的AOF文件</strong>，然后用新的AOF文件替换旧AOF文件</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6.png" alt="AOF重写机制"></p>
<h5 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h5><p>redis的重写过程由后台子进程<code>bgrewriteaof</code> （bg后台）完成：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本（<em>数据副本怎么产生的后面会说</em>），这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p>linux系统中，并不会把父进程的内存拷贝一份给子进程，而是在父子进程中任意一方进行内存页修改时，才会进行复制；</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_bgrewirteaof_%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.png" alt="redis_bgrewirteaof_写时复制"></p>
<h5 id="RDB-和-AOF-合体"><a href="#RDB-和-AOF-合体" class="headerlink" title="RDB 和 AOF 合体"></a>RDB 和 AOF 合体</h5><p>介绍：redis4.0 提出</p>
<p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<h3 id="Redis过期删除策略和内存淘汰策略"><a href="#Redis过期删除策略和内存淘汰策略" class="headerlink" title="Redis过期删除策略和内存淘汰策略"></a>Redis过期删除策略和内存淘汰策略</h3><h4 id="过期删除策略有哪些？"><a href="#过期删除策略有哪些？" class="headerlink" title="过期删除策略有哪些？"></a>过期删除策略有哪些？</h4><p>在说 Redis 过期删除策略之前，先跟大家介绍下，常见的三种过期删除策略：</p>
<ul>
<li>定时删除；<strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</strong></li>
<li>惰性删除；<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></li>
<li>定期删除；<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></li>
</ul>
<p>Redis使用的是： <strong>「惰性删除+定期删除」这两种策略配和使用</strong></p>
<p>​	</p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>前面说的过期删除策略，是删除已过期的 key，而当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行</p>
<h4 id="Redis-内存淘汰策略有哪些？"><a href="#Redis-内存淘汰策略有哪些？" class="headerlink" title="Redis 内存淘汰策略有哪些？"></a>Redis 内存淘汰策略有哪些？</h4><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p>
<p><em>1、不进行数据淘汰的策略</em></p>
<p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。</p>
<p><em>2、进行数据淘汰的策略</em></p>
<p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p>
<p>在设置了过期时间的数据中进行淘汰：</p>
<ul>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
<li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li>
<li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
</ul>
<p>在所有数据范围内进行淘汰：</p>
<ul>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li>
<li><strong>llkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li>
</ul>
<h3 id="集群高可用"><a href="#集群高可用" class="headerlink" title="集群高可用"></a>集群高可用</h3><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul>
<li>大量key同时过期</li>
<li>Redis宕机</li>
</ul>
<p>应对方法：</p>
<ul>
<li>均匀设置过期时间，使用随机数设置过期时间</li>
<li>业务对象不再更新缓存，缓存也不设置有效期；将更新缓存的工作交给后台线程；</li>
<li>互斥锁，当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul>
<li>热点key过期</li>
</ul>
<p>应对方法与缓存雪崩一致</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存中没有该数据；</p>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<ul>
<li>第一种方案，非法请求的限制；</li>
<li>第二种方案，缓存空值或者默认值；</li>
<li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/data/redis_%E7%BC%93%E5%AD%98.png" alt="redis_缓存"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/pprof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/pprof/" class="post-title-link" itemprop="url">Go pprof</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 11:32:01" itemprop="dateCreated datePublished" datetime="2023-08-22T11:32:01+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Go pprof 可以让你清晰的知道,运行中程序是如何运行,此刻他又在经历些什么</p>
<p>我们由简入深,先知道如何使用他,再深入的了解他的功能,带入到实践当中</p>
</blockquote>
<h1 id="Go-pprof-的使用"><a href="#Go-pprof-的使用" class="headerlink" title="Go pprof 的使用"></a>Go pprof 的使用</h1><p>当我们分析不同的内容时，我们需要使用到的文件也不同；</p>
<ul>
<li>cpu（CPU Profiling）: <code>/debug/pprof/profile</code>，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件</li>
<li>block（Block Profiling）：<code>/debug/pprof/block</code>，查看导致阻塞同步的堆栈跟踪</li>
<li>goroutine：<code>/debug/pprof/goroutine</code>，查看当前所有运行的 goroutines 堆栈跟踪</li>
<li>heap（Memory Profiling）: <code>/debug/pprof/heap</code>，查看活动对象的内存分配情况</li>
<li>mutex（Mutex Profiling）：<code>/debug/pprof/mutex</code>，查看导致互斥锁的竞争持有者的堆栈跟踪</li>
<li>threadcreate：<code>/debug/pprof/threadcreate</code>，查看创建新OS线程的堆栈跟踪</li>
</ul>
<p>1、按照可视化工具<code>graphviz</code></p>
<pre><code> 如果我们想要生成可视图,则需要安装 ` brew install graphviz`
</code></pre>
<p>2、生成分析文件	</p>
<p>​	<code>Go pprof</code> 首先需要代码，引入了<code>net/http/pprof</code> ,通常来说,各种GoWeb框架会自带,例如字节的<code>Kitex</code>框架等; 如果代码中引入了<code>net/http/pprof</code>则无需进行其他操作;直接执行以下命令，若没有引用，则无法使用<code>pprof</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weget http://127.0.0.1:80/pprof/profile</span><br></pre></td></tr></table></figure>

<p>3、查看文件内容	</p>
<p>​	执行上述操作后,会下载一个<code>profile</code>文件,我们下载到本地后使用 <code>go tool pprof filename</code> 查看内容;将<code>profile</code>文件下载后,执行<code>go tool pprof profile</code>即可查看内容；同时我们也可以执行<code>go tool pprof -http=:8080 profile</code>生成可视化界面,点击左上角的View即可查看火焰图;</p>
<p>以上命令总结:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用go tool 工具在线看</span><br><span class="line">go tool pprof profile</span><br><span class="line"># 使用web页面查看火焰图等可视化图</span><br><span class="line">go tool pprof -http=:8080 profile</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/uPic/image-20230628232558050.png" alt="image-20230628232558050"></p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/uPic/image-20230628231851925.png" alt="image-20230628231851925"></p>
<p>​	进入到命令页面之后,我们执行<code>top20</code>,打印消耗排名前20, 同时也可以输入<code>web</code>进入页面查看;</p>
<h1 id="pprof-指标的含义"><a href="#pprof-指标的含义" class="headerlink" title="pprof 指标的含义"></a>pprof 指标的含义</h1><h2 id="flat-flat"><a href="#flat-flat" class="headerlink" title="flat flat%"></a>flat flat%</h2><p>flat:  代表一个函数内的directly操作的耗时</p>
<p>flat:  代表flat&#x2F;总的运行时间,所有的flat相加即为总时间  </p>
<ul>
<li>directly 操作代表函数内部的CPU直接调用，若是调用其他函数等操作则不是directly操作；</li>
<li>flat越大，代表这个函数的cpu处理较多</li>
</ul>
<h2 id="cum-cum"><a href="#cum-cum" class="headerlink" title="cum cum%"></a>cum cum%</h2><p>cum:  代表一个函数内所有物理操作的耗时</p>
<p>cum:  代表cum&#x2F;总的运行时间</p>
<ul>
<li>cum越高代表某个函数执行的时间越长，此函数的性能越低；</li>
</ul>
<h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p>sum代表以上行所有flat相加</p>
<h1 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h1><p>火焰图分为两种：on_cpu, off_cpu</p>
<table>
<thead>
<tr>
<th>火焰图类型</th>
<th>横轴含义</th>
<th>纵轴含义</th>
<th>解决问题</th>
<th>采样方式</th>
</tr>
</thead>
<tbody><tr>
<td>cpu火焰图</td>
<td>cpu占用时间</td>
<td>调用栈</td>
<td>找出cpu占用高的问题函数，分析代码热路径；</td>
<td>固定频率采样cpu调用栈；</td>
</tr>
<tr>
<td>off-cpu火焰图</td>
<td>阻塞时间</td>
<td>调用栈</td>
<td>i&#x2F;o、网络等阻塞场景导致的性能下降；竞争锁，死锁导致的性能下降问题；</td>
<td>固定频率采样阻塞事件调<br/>用栈</td>
</tr>
<tr>
<td>内存火焰图</td>
<td>内存申请&#x2F;释放函数调用次数</td>
<td>调用栈</td>
<td>内存泄露问题；内存占用高的对用象&#x2F;申请内存多的函数；虚拟内存栈或物理内存泄露问题；</td>
<td>跟踪调用栈</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/prometheus/client_go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/prometheus/client_go/" class="post-title-link" itemprop="url">prometheus/client_go</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 11:32:01" itemprop="dateCreated datePublished" datetime="2023-08-22T11:32:01+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="prometheus-go-client-内存持续上涨"><a href="#prometheus-go-client-内存持续上涨" class="headerlink" title="prometheus go client 内存持续上涨"></a>prometheus go client 内存持续上涨</h1><h2 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h2><ul>
<li>网关层服务增加prometheus client 之后内存上涨10GB，造成内存报警；</li>
</ul>
<h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><p>​	增加prometheus client 之后内存上涨是在预料之内的事情，但上涨幅度达到10GB，超出预估范围100%以上！起初分析原因是因为一些未知的错误增加到detail label 上导致，比如json解析失败时，不同的字符错误会输出不同的错误类型，而世界上已知字符数量为120W！指标无限扩大！但是查询指标内容之后，发现err错误只占指标的一小部分，但依然是一个隐患，因此label的内容应该固定在指定数量以内。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">globalHttpClientHandledCounter = prom.NewCounterVec(</span><br><span class="line">		prom.CounterOpts&#123;</span><br><span class="line">			Name: <span class="string">&quot;arch_http_client_throughput&quot;</span>,</span><br><span class="line">			Help: <span class="string">&quot;Total number of http completed by the client, regardless of success or failure.&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		[]<span class="type">string</span>&#123;labelKeyServiceId, labelKeyOrganization, labelKeyCode, labelKeyHttpCode, labelKeyInnerCode, labelKeyCaller, labelKeyAppid, labelKeyOrg  ,labelKeyCallee, labelKeyDetail, labelKeyUrl, labelKeyStatus, labelKeyRetry&#125;,</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>



<p>​	继续分析原因，以上代码中，我们发现 appid&amp;org 维度有上万个不同的类型，因此可能导致维度散发从而造成数据大爆炸，Appid有1W以上不同值，Org有1K以上不同的值，因此维度相乘之后造成了数据大爆炸；因此后续我们将AppId与Org维度下线后，内存上涨幅度缩减为之前的十分之一，但这与我们预估的MB级别内存波动依然有一定差异；同时观察发现，内存在持续小幅度上涨；</p>
<p>​    <img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/uPic/image-20230523113607597.png" alt="image-20230523113607597"></p>
<p>​	</p>
<h3 id="内存持续上涨"><a href="#内存持续上涨" class="headerlink" title="内存持续上涨"></a>内存持续上涨</h3><p>​	首先解决第一个问题内存持续上涨的原因，在预期中我们预期希望的应该是当prometheus采集时，能够拿到当前有效的信息即可，不需要无效内容，比如某个公司的QPS从五天前就一直是零，那么我们认为这是一个无效数据；所以我们使用Client_golang希望采集的应该是当前的实时数据；</p>
<p>​	而实际情况是，当我们在prometheus上删除某个label时，client端依然存在；查看client_golang源码发现，prometheus client 并没有显示的去调用删除；因此指标将会一直存在内存当中，这也是导致内存会持续上涨的原因之一。</p>
<p><img src="https://raw.githubusercontent.com/yiwenqi/cloudimg/main/uPic/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_9e3ca4f4-d2c6-4943-82d9-87573ab534d8.png" alt="企业微信截图_9e3ca4f4-d2c6-4943-82d9-87573ab534d8"></p>
<h3 id="内存膨胀"><a href="#内存膨胀" class="headerlink" title="内存膨胀"></a>内存膨胀</h3><p>​	第二个问题为什么在删除AppId&amp;Org两个大范围的维度之后，内存波动依然会达到 1GB 上下？观察</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-22 11:32:01" itemprop="dateCreated datePublished" datetime="2023-08-22T11:32:01+08:00">2023-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><p> 拉取镜像</p>
<ul>
<li>docker pull mysql:tag</li>
</ul>
<p>查看镜像</p>
<ul>
<li>docker ps</li>
</ul>
<p>运行镜像</p>
<ul>
<li>docker run -d —name <xxx> -p <localPort>:<dockerPort>  dockerName:tag<ul>
<li><ul>
<li>it 交互式运行</li>
</ul>
</li>
<li><ul>
<li>d 后台运行</li>
</ul>
</li>
<li><ul>
<li>v 挂载数据卷</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>进入已运行的容器</p>
<ul>
<li>docker exec -it <CONTAINER> bash</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
